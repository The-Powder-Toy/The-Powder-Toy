#ifdef LUACONSOLE
#ifdef _MSC_VER
#include "Platform.h"
#include "resource.h"
#endif
#include "lua/LuaCompat.h"
void luaopen_crackerk(lua_State *l)
{
#ifndef _MSC_VER
	int crackerk_luac_sz = 123931;
	const char* crackerk_luac = "local jacobsmod = tpt.version.jacob1s_mod\015\n\015\nlocal icons = {\015\n\011[\"delete1\"] = \"\\xEE\\x80\\x85\",\015\n\011[\"delete2\"] = \"\\xEE\\x80\\x86\",\015\n\011[\"folder\"] = \"\\xEE\\x80\\x93\"\015\n}\015\nif jacobsmod then\015\n\011icons = {\015\n\011\011[\"delete1\"] = \"\\133\",\015\n\011\011[\"delete2\"] = \"\\134\",\015\n\011\011[\"folder\"] = \"\\147\"\015\n\011}\015\nend\015\n\015\n\015\nif not socket then error(\"TPT version not supported\") end\015\nif MANAGER then error(\"manager is already running\") end\015\n\015\nlocal scriptversion = 13\015\nMANAGER = {[\"version\"] = \"3.11\", [\"scriptversion\"] = scriptversion, [\"hidden\"] = true}\015\n\015\nlocal type = type -- people like to overwrite this function with a global a lot\015\nlocal TPT_LUA_PATH = 'scripts'\015\nlocal PATH_SEP = '\\\\'\015\nlocal OS = \"WIN32\"\015\nlocal CHECKUPDATE = false\015\nlocal EXE_NAME\015\nif platform then\015\n\011OS = platform.platform()\015\n\011if OS ~= \"WIN32\" and OS ~= \"WIN64\" then\015\n\011\011PATH_SEP = '/'\015\n\011end\015\n\011EXE_NAME = platform.exeName()\015\n\011local temp = EXE_NAME:reverse():find(PATH_SEP)\015\n\011EXE_NAME = EXE_NAME:sub(#EXE_NAME-temp+2)\015\nelse\015\n\011if os.getenv('HOME') then\015\n\011\011PATH_SEP = '/'\015\n\011\011if fs.exists(\"/Applications\") then\015\n\011\011\011OS = \"MACOSX\"\015\n\011\011else\015\n\011\011\011OS = \"LIN64\"\015\n\011\011end\015\n\011end\015\n\011if OS == \"WIN32\" or OS == \"WIN64\" then\015\n\011\011EXE_NAME = jacobsmod and \"Jacob1\\'s Mod.exe\" or \"Powder.exe\"\015\n\011elseif OS == \"MACOSX\" then\015\n\011\011EXE_NAME = \"powder-x\" --can't restart on OS X (if using < 91.0)\015\n\011else\015\n\011\011EXE_NAME = jacobsmod and \"Jacob1\\'s Mod\" or \"powder\"\015\n\011end\015\nend\015\nlocal filenames = {}\015\nlocal num_files = 0 --downloaded scripts aren't stored in filenames\015\nlocal localscripts = {}\015\nlocal onlinescripts = {}\015\nlocal running = {}\015\nlocal requiresrestart=false\015\nlocal online = false\015\nlocal first_online = true\015\nlocal updatetable --temporarily holds info on script manager updates\015\nlocal gen_buttons\015\nlocal sidebutton\015\nlocal download_file\015\nlocal settings = {}\015\nmath.randomseed(os.time()) math.random() math.random() math.random() --some filler randoms\015\n\015\n--get line that can be saved into scriptinfo file\015\nlocal function scriptInfoString(info)\015\n\011--Write table into data format\015\n\011if type(info)~=\"table\" then return end\015\n\011local t = {}\015\n\011for k,v in pairs(info) do\015\n\011\011table.insert(t,k..\":\\\"\"..v..\"\\\"\")\015\n\011end\015\n\011local rstr = table.concat(t,\",\"):gsub(\"\\r\",\"\"):gsub(\"\\n\",\"\\\\n\")\015\n\011return rstr\015\nend\015\n\015\n--read a scriptinfo line\015\nlocal function readScriptInfo(list)\015\n\011if not list then return {} end\015\n\011local scriptlist = {}\015\n\011for i in list:gmatch(\"[^\\n]+\") do\015\n\011\011local t = {}\015\n\011\011local ID = 0\015\n\011\011for k,v in i:gmatch(\"(%w+):\\\"([^\\\"]*)\\\"\") do\015\n\011\011\011t[k]= tonumber(v) or v:gsub(\"\\r\",\"\"):gsub(\"\\\\n\",\"\\n\")\015\n\011\011end\015\n\011\011scriptlist[t.ID] = t\015\n\011end\015\n\011return scriptlist\015\nend\015\n\015\n--save settings\015\nlocal function save_last()\015\n\011local savestring=\"\"\015\n\011for script,v in pairs(running) do\015\n\011\011savestring = savestring..\" \\\"\"..script..\"\\\"\"\015\n\011end\015\n\011savestring = \"SAV \"..savestring..\"\\nDIR \"..TPT_LUA_PATH\015\n\011for k,t in pairs(settings) do\015\n\011for n,v in pairs(t) do\015\n\011\011savestring = savestring..\"\\nSET \"..k..\" \"..n..\":\\\"\"..v..\"\\\"\"\015\n\011end\015\n\011end\015\n\011local f\015\n\011if TPT_LUA_PATH == \"scripts\" then\015\n\011\011f = io.open(TPT_LUA_PATH..PATH_SEP..\"autorunsettings.txt\", \"w\")\015\n\011else\015\n\011\011f = io.open(\"autorunsettings.txt\", \"w\")\015\n\011end\015\n\011if f then\015\n\011\011f:write(savestring)\015\n\011\011f:close()\015\n\011end\015\n\015\n\011f = io.open(TPT_LUA_PATH..PATH_SEP..\"downloaded\"..PATH_SEP..\"scriptinfo\", \"w\")\015\n\011if f then\015\n\011\011for k,v in pairs(localscripts) do\015\n\011\011\011f:write(scriptInfoString(v)..\"\\n\")\015\n\011\011end\015\n\011\011f:close()\015\n\011end\015\nend\015\n\015\nlocal function load_downloaded()\015\n\011local f = io.open(TPT_LUA_PATH..PATH_SEP..\"downloaded\"..PATH_SEP..\"scriptinfo\",\"r\")\015\n\011if f then\015\n\011\011local lines = f:read(\"*a\")\015\n\011\011f:close()\015\n\011\011localscripts = readScriptInfo(lines)\015\n\011\011for k,v in pairs(localscripts) do\015\n\011\011\011if k ~= 1 then\015\n\011\011\011\011if not v[\"ID\"] or not v[\"name\"] or not v[\"description\"] or not v[\"path\"] or not v[\"version\"] then\015\n\011\011\011\011\011localscripts[k] = nil\015\n\011\011\011\011elseif not fs.exists(TPT_LUA_PATH..\"/\"..v[\"path\"]:gsub(\"\\\\\",\"/\")) then\015\n\011\011\011\011\011 localscripts[k] = nil\015\n\011\011\011\011end\015\n\011\011\011end\015\n\011\011end\015\n\011end\015\nend\015\n\015\n--load settings before anything else\015\nlocal function load_last()\015\n\011local f = io.open(TPT_LUA_PATH..PATH_SEP..\"autorunsettings.txt\",\"r\")\015\n\011if not f then\015\n\011\011f = io.open(\"autorunsettings.txt\",\"r\")\015\n\011end\015\n\011if f then\015\n\011\011local lines = {}\015\n\011\011local line = f:read(\"*l\")\015\n\011\011while line do\015\n\011\011\011table.insert(lines,(line:gsub(\"\\r\",\"\")))\015\n\011\011\011line = f:read(\"*l\")\015\n\011\011end\015\n\011\011f:close()\015\n\011\011for i=1, #lines do\015\n\011\011\011local tok=lines[i]:sub(1,3)\015\n\011\011\011local str=lines[i]:sub(5)\015\n\011\011\011if tok==\"SAV\" then\015\n\011\011\011\011for word in string.gmatch(str, \"\\\"(.-)\\\"\") do running[word] = true end\015\n\011\011\011elseif tok==\"EXE\" then\015\n\011\011\011\011EXE_NAME=str\015\n\011\011\011elseif tok==\"DIR\" then\015\n\011\011\011\011TPT_LUA_PATH=str\015\n\011\011\011elseif tok==\"SET\" then\015\n\011\011\011\011local ident,name,val = string.match(str,\"(.-) (.-):\\\"(.-)\\\"\")\015\n\011\011\011\011if settings[ident] then settings[ident][name]=val\015\n\011\011\011\011else settings[ident]={[name]=val} end\015\n\011\011\011end\015\n\011\011end\015\n\011end\015\n\015\n\011load_downloaded()\015\nend\015\nload_last()\015\n--get list of files in scripts folder\015\nlocal function load_filenames()\015\n\011filenames = {}\015\n\011local function searchRecursive(directory)\015\n\011\011local dirlist = fs.list(directory)\015\n\011\011if not dirlist then return end\015\n\011\011for i,v in ipairs(dirlist) do\015\n\011\011\011local file = directory..\"/\"..v\015\n\011\011\011if fs.isDirectory(file) and v ~= \"downloaded\" then\015\n\011\011\011\011searchRecursive(file)\015\n\011\011\011elseif fs.isFile(file) then\015\n\011\011\011\011if file:find(\"%.lua$\") then\015\n\011\011\011\011\011local toinsert = file:sub(#TPT_LUA_PATH+2)\015\n\011\011\011\011\011if OS == \"WIN32\" or OS == \"WIN64\" then\015\n\011\011\011\011\011\011toinsert = toinsert:gsub(\"/\", \"\\\\\") --not actually required\015\n\011\011\011\011\011end\015\n\011\011\011\011\011table.insert(filenames, toinsert)\015\n\011\011\011\011end\015\n\011\011\011end\015\n\011\011end\015\n\011end\015\n\011searchRecursive(TPT_LUA_PATH)\015\n\011table.sort(filenames, function(first,second) return first:lower() < second:lower() end)\015\nend\015\n--ui object stuff\015\nlocal ui_base local ui_box local ui_line local ui_text local ui_button local ui_scrollbar local ui_tooltip local ui_checkbox local ui_console local ui_window\015\nlocal tooltip\015\nui_base = {\015\nnew = function()\015\n\011local b={}\015\n\011b.drawlist = {}\015\n\011function b:drawadd(f)\015\n\011\011table.insert(self.drawlist,f)\015\n\011end\015\n\011function b:draw(...)\015\n\011\011for _,f in ipairs(self.drawlist) do\015\n\011\011\011if type(f)==\"function\" then\015\n\011\011\011\011f(self,...)\015\n\011\011\011end\015\n\011\011end\015\n\011end\015\n\011b.movelist = {}\015\n\011function b:moveadd(f)\015\n\011\011table.insert(self.movelist,f)\015\n\011end\015\n\011function b:onmove(x,y)\015\n\011\011for _,f in ipairs(self.movelist) do\015\n\011\011\011if type(f)==\"function\" then\015\n\011\011\011\011f(self,x,y)\015\n\011\011\011end\015\n\011\011end\015\n\011end\015\n\011return b\015\nend\015\n}\015\nui_box = {\015\nnew = function(x,y,w,h,r,g,b)\015\n\011local box=ui_base.new()\015\n\011box.x=x box.y=y box.w=w box.h=h box.x2=x+w box.y2=y+h\015\n\011box.r=r or 100 box.g=g or 100 box.b= 255\015\n\011function box:setcolor(r,g,b) self.r=r self.g=g self.b=b end\015\n\011function box:setbackground(r,g,b,a) self.br=r self.bg=g self.bb=b self.ba=a end\015\n\011box.drawbox=true\015\n\011box.drawbackground=false\015\n\011box:drawadd(function(self) if self.drawbackground then tpt.fillrect(self.x,self.y,self.w+1,self.h+1,self.br,self.bg,self.bb,self.ba) end\015\n\011\011\011\011\011\011\011\011if self.drawbox then tpt.drawrect(self.x,self.y,self.w,self.h,self.r,self.g,self.b) end end)\015\n\011box:moveadd(function(self,x,y)\015\n\011\011if x then self.x=self.x+x self.x2=self.x2+x end\015\n\011\011if y then self.y=self.y+y self.y2=self.y2+y end\015\n\011end)\015\n\011return box\015\nend\015\n}\015\nui_line = {\015\nnew=function(x,y,x2,y2,r,g,b)\015\n\011local line=ui_box.new(x,y,x2-x,y2-y,r,g,b)\015\n\011--Line is essentially a box, but with a different draw\015\n\011line.drawlist={}\015\n\011line:drawadd(function(self) tpt.drawline(self.x,self.y,self.x2,self.y2,self.r,self.g,self.b) end)\015\n\011return line\015\n\011end\015\n}\015\nui_text = {\015\nnew = function(text,x,y,r,g,b)\015\n\011local txt = ui_base.new()\015\n\011txt.text = text\015\n\011txt.x=x or 0 txt.y=y or 0 txt.r=r or 255 txt.g=g or 255 txt.b=b or 255\015\n\011function txt:setcolor(r,g,b) self.r=r self.g=g self.b=b end\015\n\011txt:drawadd(function(self,x,y) tpt.drawtext(x or self.x,y or self.y,self.text,self.r,self.g,self.b) end)\015\n\011txt:moveadd(function(self,x,y)\015\n\011\011if x then self.x=self.x+x end\015\n\011\011if y then self.y=self.y+y end\015\n\011end)\015\n\011function txt:process() return false end\015\n\011return txt\015\nend,\015\n--Scrolls while holding mouse over\015\nnewscroll = function(text,x,y,vis,r,g,b)\015\n\011local txt = ui_text.new(text,x,y,r,g,b)\015\n\011if tpt.textwidth(text)<vis then return txt end\015\n\011txt.visible=vis\015\n\011txt.length=string.len(text)\015\n\011txt.start=1\015\n\011txt.drawlist={} --reset draw\015\n\011txt.timer=socket.gettime()+3\015\n\011function txt:cuttext(self)\015\n\011\011local last = self.start+1\015\n\011\011while tpt.textwidth(self.text:sub(self.start,last))<txt.visible and last<=self.length do\015\n\011\011\011last = last+1\015\n\011\011end\015\n\011\011self.last=last-1\015\n\011end\015\n\011txt:cuttext(txt)\015\n\011txt.minlast=txt.last-1\015\n\011txt.ppl=((txt.visible-6)/(txt.length-txt.minlast+1))\015\n\011txt:drawadd(function(self,x,y)\015\n\011\011if socket.gettime() > self.timer then\015\n\011\011\011if self.last >= self.length then\015\n\011\011\011\011self.start = 1\015\n\011\011\011\011self:cuttext(self)\015\n\011\011\011\011self.timer = socket.gettime()+3\015\n\011\011\011else\015\n\011\011\011\011self.start = self.start + 1\015\n\011\011\011\011self:cuttext(self)\015\n\011\011\011\011if self.last >= self.length then\015\n\011\011\011\011\011self.timer = socket.gettime()+3\015\n\011\011\011\011else\015\n\011\011\011\011\011self.timer = socket.gettime()+.15\015\n\011\011\011\011end\015\n\011\011\011end\015\n\011\011end\015\n\011\011tpt.drawtext(x or self.x,y or self.y, self.text:sub(self.start,self.last) ,self.r,self.g,self.b)\015\n\011end)\015\n\011function txt:process(mx,my,button,event,wheel)\015\n\011\011if event==3 then\015\n\011\011\011local newlast = math.floor((mx-self.x)/self.ppl)+self.minlast\015\n\011\011\011if newlast<self.minlast then newlast=self.minlast end\015\n\011\011\011if newlast>0 and newlast~=self.last then\015\n\011\011\011\011local newstart=1\015\n\011\011\011\011while tpt.textwidth(self.text:sub(newstart,newlast))>= self.visible do\015\n\011\011\011\011\011newstart=newstart+1\015\n\011\011\011\011end\015\n\011\011\011\011self.start=newstart self.last=newlast\015\n\011\011\011\011self.timer = socket.gettime()+3\015\n\011\011\011end\015\n\011\011end\015\n\011end\015\n\011return txt\015\nend\015\n}\015\nui_scrollbar = {\015\nnew = function(x,y,h,t,m)\015\n\011local bar = ui_base.new() --use line object as base?\015\n\011bar.x=x bar.y=y bar.h=h\015\n\011bar.total=t\015\n\011bar.numshown=m\015\n\011bar.pos=0\015\n\011bar.length=math.floor((1/math.ceil(bar.total-bar.numshown+1))*bar.h)\015\n\011bar.soffset=math.floor(bar.pos*((bar.h-bar.length)/(bar.total-bar.numshown)))\015\n\011function bar:update(total,shown,pos)\015\n\011\011self.pos=pos or 0\015\n\011\011if self.pos<0 then self.pos=0 end\015\n\011\011self.total=total\015\n\011\011self.numshown=shown\015\n\011\011self.length= math.floor((1/math.ceil(self.total-self.numshown+1))*self.h)\015\n\011\011self.soffset= math.floor(self.pos*((self.h-self.length)/(self.total-self.numshown)))\015\n\011end\015\n\011function bar:move(wheel)\015\n\011\011self.pos = self.pos-wheel\015\n\011\011if self.pos < 0 then self.pos=0 end\015\n\011\011if self.pos > (self.total-self.numshown) then self.pos=(self.total-self.numshown) end\015\n\011\011self.soffset= math.floor(self.pos*((self.h-self.length)/(self.total-self.numshown)))\015\n\011end\015\n\011bar:drawadd(function(self)\015\n\011\011if self.total > self.numshown then\015\n\011\011\011tpt.drawline(self.x,self.y+self.soffset,self.x,self.y+self.soffset+self.length)\015\n\011\011end\015\n\011end)\015\n\011bar:moveadd(function(self,x,y)\015\n\011\011if x then self.x=self.x+x end\015\n\011\011if y then self.y=self.y+y end\015\n\011end)\015\n\011function bar:process(mx,my,button,event,wheel)\015\n\011\011if wheel~=0 and not MANAGER.hidden then\015\n\011\011\011if self.total > self.numshown then\015\n\011\011\011\011local previous = self.pos\015\n\011\011\011\011self:move(wheel)\015\n\011\011\011\011if self.pos~=previous then\015\n\011\011\011\011\011return previous-self.pos\015\n\011\011\011\011end\015\n\011\011\011end\015\n\011\011end\015\n\011\011--possibly click the bar and drag?\015\n\011\011return false\015\n\011end\015\n\011return bar\015\nend\015\n}\015\nui_button = {\015\nnew = function(x,y,w,h,f,text)\015\n\011local b = ui_box.new(x,y,w,h)\015\n\011b.f=f\015\n\011b.t=ui_text.new(text,x+2,y+2)\015\n\011b.drawbox=false\015\n\011b.clicked=false\015\n\011b.almostselected=false\015\n\011b.invert=true\015\n\011b:setbackground(127,127,127,125)\015\n\011b:drawadd(function(self)\015\n\011\011if self.invert and self.almostselected then\015\n\011\011\011self.almostselected=false\015\n\011\011\011tpt.fillrect(self.x,self.y,self.w,self.h)\015\n\011\011\011local tr=self.t.r local tg=self.t.g local tb=self.t.b\015\n\011\011\011b.t:setcolor(0,0,0)\015\n\011\011\011b.t:draw()\015\n\011\011\011b.t:setcolor(tr,tg,tb)\015\n\011\011else\015\n\011\011\011if tpt.mousex>=self.x and tpt.mousex<=self.x2 and tpt.mousey>=self.y and tpt.mousey<=self.y2 then\015\n\011\011\011\011self.drawbackground=true\015\n\011\011\011else\015\n\011\011\011\011self.drawbackground=false\015\n\011\011\011end\015\n\011\011\011b.t:draw()\015\n\011\011end\015\n\011end)\015\n\011b:moveadd(function(self,x,y)\015\n\011\011self.t:onmove(x,y)\015\n\011end)\015\n\011function b:process(mx,my,button,event,wheel)\015\n\011\011local clicked = self.clicked\015\n\011\011if event==2 then self.clicked = false end\015\n\011\011if mx<self.x or mx>self.x2 or my<self.y or my>self.y2 then return false end\015\n\011\011if event==1 then\015\n\011\011\011self.clicked=true\015\n\011\011elseif clicked then\015\n\011\011\011if event==3 then self.almostselected=true end\015\n\011\011\011if event==2 then self:f() end\015\n\011\011\011return true\015\n\011\011end\015\n\011end\015\n\011return b\015\nend\015\n}\015\nui_tooltip = {\015\nnew = function(x,y,w,text)\015\n\011local b = ui_box.new(x,y-1,w,0)\015\n\011function b:updatetooltip(tooltip)\015\n\011\011self.tooltip = tooltip\015\n\011\011self.length = #tooltip\015\n\011\011self.lines = 1\015\n\015\n\011\011local linebreak,lastspace = 0,nil\015\n\011\011for i=0,#self.tooltip do\015\n\011\011\011local width = tpt.textwidth(tooltip:sub(linebreak,i+1))\015\n\011\011\011if width > self.w/2 and tooltip:sub(i,i):match(\"[%s,_%.%-?!]\") then\015\n\011\011\011\011lastspace = i\015\n\011\011\011end\015\n\011\011\011local isnewline = (self.tooltip:sub(i,i) == '\\n')\015\n\011\011\011if width > self.w or isnewline then\015\n\011\011\011\011local pos = (i==#tooltip or not lastspace) and i or lastspace\015\n\011\011\011\011self.lines = self.lines + 1\015\n\011\011\011\011if self.tooltip:sub(pos,pos) == ' ' then\015\n\011\011\011\011\011self.tooltip = self.tooltip:sub(1,pos-1)..\"\\n\"..self.tooltip:sub(pos+1)\015\n\011\011\011\011elseif not isnewline then\015\n\011\011\011\011\011self.length = self.length + 1\015\n\011\011\011\011\011self.tooltip = self.tooltip:sub(1,pos-1)..\"\\n\"..self.tooltip:sub(pos)\015\n\011\011\011\011\011i = i + 1\015\n\011\011\011\011\011pos = pos + 1\015\n\011\011\011\011end\015\n\011\011\011\011linebreak = pos+1\015\n\011\011\011\011lastspace = nil\015\n\011\011\011end\015\n\011\011end\015\n\011\011self.h = self.lines*12+2\015\n\011\011if self.y + self.h > gfx.HEIGHT then\015\n\011\011\011local movement = (gfx.HEIGHT-self.h-1)-self.y\015\n\011\011\011if self.y+movement < 0 then\015\n\011\011\011\011movement = -self.y\015\n\011\011\011end\015\n\011\011\011self:onmove(0, movement)\015\n\011\011end\015\n\011\011--self.w = tpt.textwidth(self.tooltip)+3\015\n\011\011self.drawbox = tooltip ~= \"\"\015\n\011\011self.drawbackground = tooltip ~= \"\"\015\n\011end\015\n\011function b:settooltip(tooltip_)\015\n\011\011tooltip:onmove(tpt.mousex+5-tooltip.x, tpt.mousey+5-tooltip.y)\015\n\011\011tooltip:updatetooltip(tooltip_)\015\n\011end\015\n\011b:updatetooltip(text)\015\n\011b:setbackground(0,0,0,255)\015\n\011b.drawbackground = true\015\n\011b:drawadd(function(self)\015\n\011\011if self.tooltip ~= \"\" then\015\n\011\011\011tpt.drawtext(self.x+1,self.y+2,self.tooltip)\015\n\011\011end\015\n\011\011self:updatetooltip(\"\")\015\n\011end)\015\n\011function b:process(mx,my,button,event,wheel) end\015\n\011return b\015\nend\015\n}\015\nui_checkbox = {\015\nup_button = function(x,y,w,h,f,text)\015\n\011local b=ui_button.new(x,y,w,h,f,text)\015\n\011b.canupdate=false\015\n\011return b\015\nend,\015\nnew_button = function(x,y,w,h,splitx,f,f2,text,localscript)\015\n\011local b = ui_box.new(x,y,splitx,h)\015\n\011b.f=f b.f2=f2\015\n\011b.localscript=localscript\015\n\011b.splitx = splitx\015\n\011b.t=ui_text.newscroll(text,x+24,y+2,splitx-24)\015\n\011b.clicked=false\015\n\011b.selected=false\015\n\011b.checkbut=ui_checkbox.up_button(x+splitx+9,y,33,9,ui_button.scriptcheck,\"Update\")\015\n\011b.drawbox=false\015\n\011b:setbackground(127,127,127,100)\015\n\011b:drawadd(function(self)\015\n\011\011if self.t.text == \"\" then return end\015\n\011\011self.drawbackground = false\015\n\011\011if tpt.mousey >= self.y and tpt.mousey < self.y2 then\015\n\011\011\011if tpt.mousex >= self.x and tpt.mousex < self.x+8 then\015\n\011\011\011\011if self.localscript then\015\n\011\011\011\011\011tooltip:settooltip(\"delete this script\")\015\n\011\011\011\011else\015\n\011\011\011\011\011tooltip:settooltip(\"view script in browser\")\015\n\011\011\011\011end\015\n\011\011\011elseif tpt.mousex>=self.x and tpt.mousex<self.x2 then\015\n\011\011\011\011local script\015\n\011\011\011\011if online and onlinescripts[self.ID][\"description\"] then\015\n\011\011\011\011\011script = onlinescripts[self.ID]\015\n\011\011\011\011elseif not online and localscripts[self.ID] then\015\n\011\011\011\011\011script = localscripts[self.ID]\015\n\011\011\011\011end\015\n\011\011\011\011if script then\015\n\011\011\011\011\011tooltip:settooltip(script[\"name\"]..\" by \"..script[\"author\"]..\"\\n\\n\"..script[\"description\"])\015\n\011\011\011\011end\015\n\011\011\011\011self.drawbackground = true\015\n\011\011\011elseif tpt.mousex >= self.x2 then\015\n\011\011\011\011if tpt.mousex < self.x2+9 and self.running then\015\n\011\011\011\011\011tooltip:settooltip(online and \"downloaded\" or \"running\")\015\n\011\011\011\011elseif tpt.mousex >= self.x2+9 and tpt.mousex < self.x2+43 and self.checkbut.canupdate and onlinescripts[self.ID] and onlinescripts[self.ID][\"changelog\"] then\015\n\011\011\011\011\011tooltip:settooltip(onlinescripts[self.ID][\"changelog\"])\015\n\011\011\011\011end\015\n\011\011\011end\015\n\011\011end\015\n\011\011self.t:draw()\015\n\011\011if self.localscript then\015\n\011\011\011local swapicon = tpt.version.jacob1s_mod_build and tpt.version.jacob1s_mod_build > 76\015\n\011\011\011local offsetX = swapicon and 1 or 0\015\n\011\011\011local offsetY = swapicon and 2 or 0\015\n\011\011\011local innericon = swapicon and icons[\"delete1\"] or icons[\"delete2\"]\015\n\011\011\011local outericon = swapicon and icons[\"delete2\"] or icons[\"delete1\"]\015\n\011\011\011if self.deletealmostselected then\015\n\011\011\011\011self.deletealmostselected = false\015\n\011\011\011\011tpt.drawtext(self.x+1+offsetX, self.y+1+offsetY, innericon, 255, 48, 32, 255)\015\n\011\011\011else\015\n\011\011\011\011tpt.drawtext(self.x+1+offsetX, self.y+1+offsetY, innericon, 160, 48, 32, 255)\015\n\011\011\011end\015\n\011\011\011tpt.drawtext(self.x+1+offsetX, self.y+1+offsetY, outericon, 255, 255, 255, 255)\015\n\011\011else\015\n\011\011\011tpt.drawtext(self.x+1, self.y+1, icons[\"folder\"], 255, 200, 80, 255)\015\n\011\011end\015\n\011\011tpt.drawrect(self.x+12,self.y+1,8,8)\015\n\011\011if self.almostselected then self.almostselected=false tpt.fillrect(self.x+12,self.y+1,8,8,150,150,150)\015\n\011\011elseif self.selected then tpt.fillrect(self.x+12,self.y+1,8,8) end\015\n\011\011local filepath = self.ID and localscripts[self.ID] and localscripts[self.ID][\"path\"] or self.t.text\015\n\011\011if self.running then tpt.drawtext(self.x+self.splitx+2,self.y+2,online and \"D\" or \"R\") end\015\n\011\011if self.checkbut.canupdate then self.checkbut:draw() end\015\n\011end)\015\n\011b:moveadd(function(self,x,y)\015\n\011\011self.t:onmove(x,y)\015\n\011\011self.checkbut:onmove(x,y)\015\n\011end)\015\n\011function b:process(mx,my,button,event,wheel)\015\n\011\011if self.f2 and mx <= self.x+8 then\015\n\011\011\011if event==1 then\015\n\011\011\011\011self.clicked = 1\015\n\011\011\011elseif self.clicked == 1 then\015\n\011\011\011\011if event==3 then self.deletealmostselected = true end\015\n\011\011\011\011if event==2 then self:f2() end\015\n\011\011\011end\015\n\011\011elseif self.f and mx<=self.x+self.splitx then\015\n\011\011\011if event==1 then\015\n\011\011\011\011self.clicked = 2\015\n\011\011\011elseif self.clicked == 2 then\015\n\011\011\011\011if event==3 then self.almostselected=true end\015\n\011\011\011\011if event==2 then self:f() end\015\n\011\011\011\011self.t:process(mx,my,button,event,wheel)\015\n\011\011\011end\015\n\011\011else\015\n\011\011\011if self.checkbut.canupdate then self.checkbut:process(mx,my,button,event,wheel) end\015\n\011\011end\015\n\011\011return true\015\n\011end\015\n\011return b\015\nend,\015\nnew = function(x,y,w,h)\015\n\011local box = ui_box.new(x,y,w,h)\015\n\011box.list={}\015\n\011box.numlist = 0\015\n\011box.max_lines = math.floor(box.h/10)-1\015\n\011box.max_text_width = math.floor(box.w*0.8)\015\n\011box.splitx=x+box.max_text_width\015\n\011box.scrollbar = ui_scrollbar.new(box.x2-2,box.y+11,box.h-12,0,box.max_lines)\015\n\011box.lines={\015\n\011\011ui_line.new(box.x+1,box.y+10,box.x2-1,box.y+10,170,170,170),\015\n\011\011ui_line.new(box.x+22,box.y+10,box.x+22,box.y2-1,170,170,170),\015\n\011\011ui_line.new(box.splitx,box.y+10,box.splitx,box.y2-1,170,170,170),\015\n\011\011ui_line.new(box.splitx+9,box.y+10,box.splitx+9,box.y2-1,170,170,170),\015\n\011}\015\n\011function box:updatescroll()\015\n\011\011self.scrollbar:update(self.numlist,self.max_lines)\015\n\011end\015\n\011function box:clear()\015\n\011\011self.list={}\015\n\011\011self.numlist=0\015\n\011end\015\n\011function box:add(f,f2,text,localscript)\015\n\011\011local but = ui_checkbox.new_button(self.x,self.y+1+((self.numlist+1)*10),tpt.textwidth(text)+4,10,self.max_text_width,f,f2,text,localscript)\015\n\011\011table.insert(self.list,but)\015\n\011\011self.numlist = #self.list\015\n\011\011return but\015\n\011end\015\n\011box:drawadd(function (self)\015\n\011\011tpt.drawtext(self.x+24,self.y+2,\"Files in \"..TPT_LUA_PATH..\" folder\")\015\n\011\011tpt.drawtext(self.splitx+11,self.y+2,\"Update\")\015\n\011\011for i,line in ipairs(self.lines) do\015\n\011\011\011line:draw()\015\n\011\011end\015\n\011\011self.scrollbar:draw()\015\n\011\011local restart = false\015\n\011\011for i,check in ipairs(self.list) do\015\n\011\011\011local filepath = check.ID and localscripts[check.ID] and localscripts[check.ID][\"path\"] or check.t.text\015\n\011\011\011if not check.selected and running[filepath] then\015\n\011\011\011\011restart = true\015\n\011\011\011end\015\n\011\011\011if i>self.scrollbar.pos and i<=self.scrollbar.pos+self.max_lines then\015\n\011\011\011\011check:draw()\015\n\011\011\011end\015\n\011\011end\015\n\011\011requiresrestart = restart and not online\015\n\011end)\015\n\011box:moveadd(function(self,x,y)\015\n\011\011for i,line in ipairs(self.lines) do\015\n\011\011\011line:onmove(x,y)\015\n\011\011end\015\n\011\011for i,check in ipairs(self.list) do\015\n\011\011\011check:onmove(x,y)\015\n\011\011end\015\n\011end)\015\n\011function box:scroll(amount)\015\n\011\011local move = amount*10\015\n\011\011if move==0 then return end\015\n\011\011for i,check in ipairs(self.list) do\015\n\011\011\011check:onmove(0,move)\015\n\011\011end\015\n\011end\015\n\011function box:process(mx,my,button,event,wheel)\015\n\011\011if mx<self.x or mx>self.x2 or my<self.y or my>self.y2-7 then return false end\015\n\011\011local scrolled = self.scrollbar:process(mx,my,button,event,wheel)\015\n\011\011if scrolled then self:scroll(scrolled) end\015\n\011\011local which = math.floor((my-self.y-11)/10)+1\015\n\011\011if which>0 and which<=self.numlist then self.list[which+self.scrollbar.pos]:process(mx,my,button,event,wheel) end\015\n\011\011if event == 2 then\015\n\011\011\011for i,v in ipairs(self.list) do v.clicked = false end\015\n\011\011end\015\n\011\011return true\015\n\011end\015\n\011return box\015\nend\015\n}\015\nui_console = {\015\nnew = function(x,y,w,h)\015\n\011local con = ui_box.new(x,y,w,h)\015\n\011con.shown_lines = math.floor(con.h/10)\015\n\011con.max_lines = 300\015\n\011con.max_width = con.w-4\015\n\011con.lines = {}\015\n\011con.scrollbar = ui_scrollbar.new(con.x2-2,con.y+1,con.h-2,0,con.shown_lines)\015\n\011con:drawadd(function(self)\015\n\011\011self.scrollbar:draw()\015\n\011\011local count=0\015\n\011\011for i,line in ipairs(self.lines) do\015\n\011\011\011if i>self.scrollbar.pos and i<= self.scrollbar.pos+self.shown_lines then\015\n\011\011\011\011line:draw(self.x+3,self.y+3+(count*10))\015\n\011\011\011\011count = count+1\015\n\011\011\011end\015\n\011\011end\015\n\011end)\015\n\011con:moveadd(function(self,x,y)\015\n\011\011self.scrollbar:onmove(x,y)\015\n\011end)\015\n\011function con:clear()\015\n\011\011self.lines = {}\015\n\011\011self.scrollbar:update(0,con.shown_lines)\015\n\011end\015\n\011function con:addstr(str,r,g,b)\015\n\011\011str = tostring(str)\015\n\011\011local nextl = str:find('\\n')\015\n\011\011while nextl do\015\n\011\011\011local line = str:sub(1,nextl-1)\015\n\011\011\011self:addline(line,r,g,b)\015\n\011\011\011str = str:sub(nextl+1)\015\n\011\011\011nextl = str:find('\\n')\015\n\011\011end\015\n\011\011self:addline(str,r,g,b) --anything leftover\015\n\011end\015\n\011function con:addline(line,r,g,b)\015\n\011\011if not line or line==\"\" then return end --No blank lines\015\n\011\011table.insert(self.lines,ui_text.newscroll(line,self.x,0,self.max_width,r,g,b))\015\n\011\011if #self.lines>self.max_lines then table.remove(self.lines,1) end\015\n\011\011self.scrollbar:update(#self.lines,self.shown_lines,#self.lines-self.shown_lines)\015\n\011end\015\n\011function con:process(mx,my,button,event,wheel)\015\n\011\011if mx<self.x or mx>self.x2 or my<self.y or my>self.y2 then return false end\015\n\011\011self.scrollbar:process(mx,my,button,event,wheel)\015\n\011\011local which = math.floor((my-self.y-1)/10)+1\015\n\011\011if which>0 and which<=self.shown_lines and self.lines[which+self.scrollbar.pos] then self.lines[which+self.scrollbar.pos]:process(mx,my,button,event,wheel) end\015\n\011\011return true\015\n\011end\015\n\011return con\015\nend\015\n}\015\nui_window = {\015\nnew = function(x,y,w,h)\015\n\011local w=ui_box.new(x,y,w,h)\015\n\011w.sub={}\015\n\011function w:add(m,name)\015\n\011\011if name then w[name]=m end\015\n\011\011table.insert(self.sub,m)\015\n\011end\015\n\011w:drawadd(function(self)\015\n\011\011for i,sub in ipairs(self.sub) do\015\n\011\011\011sub:draw()\015\n\011\011end\015\n\011end)\015\n\011w:moveadd(function(self,x,y)\015\n\011\011for i,sub in ipairs(self.sub) do\015\n\011\011\011sub:onmove(x,y)\015\n\011\011end\015\n\011end)\015\n\011function w:process(mx,my,button,event,wheel)\015\n\011\011if mx<self.x or mx>self.x2 or my<self.y or my>self.y2 then if button == 0 then return end ui_button.sidepressed() return true end\015\n\011\011local ret\015\n\011\011for i,sub in ipairs(self.sub) do\015\n\011\011\011if sub:process(mx,my,button,event,wheel) then ret = true end\015\n\011\011end\015\n\011\011return ret\015\n\011end\015\n\011return w\015\nend\015\n}\015\n--Main window with everything!\015\nlocal mainwindow = ui_window.new(50,50,525,300)\015\nmainwindow:setbackground(10,10,10,235) mainwindow.drawbackground=true\015\nmainwindow:add(ui_console.new(275,148,300,189),\"menuconsole\")\015\nmainwindow:add(ui_checkbox.new(50,80,225,257),\"checkbox\")\015\ntooltip = ui_tooltip.new(0,1,250,\"\")\015\n\015\n--Some API functions you can call from other scripts\015\n--put 'using_manager=MANAGER ~= nil' or similar in your scripts, using_manager will be true if the manager is active\015\n--Print a message to the manager console, can be colored\015\nfunction MANAGER.print(msg,...)\015\n\011mainwindow.menuconsole:addstr(msg,...)\015\nend\015\n--downloads and returns a file, so you can do whatever...\015\nlocal download_file\015\nfunction MANAGER.download(url)\015\n\011return download_file(url)\015\nend\015\nfunction MANAGER.scriptinfo(id)\015\n\011local url = \"http://starcatcher.us/scripts/main.lua\"\015\n\011if id then\015\n\011\011url = url..\"?info=\"..id\015\n\011end\015\n\011local info = download_file(url)\015\n\011infotable = readScriptInfo(info)\015\n\011return id and infotable[id] or infotable\015\nend\015\n--Get various info about the system (operating system, script directory, path seperator, if socket is loaded)\015\nfunction MANAGER.sysinfo()\015\n\011return {[\"OS\"]=OS, [\"scriptDir\"]=TPT_LUA_PATH, [\"pathSep\"]=PATH_SEP, [\"exeName\"] = EXE_NAME}\015\nend\015\n--Save a setting in the autorun settings file, ident should be your script name no one else would use.\015\n--Name is variable name, val is the value which will be saved/returned as a string\015\nfunction MANAGER.savesetting(ident,name,val)\015\n\011ident = tostring(ident)\015\n\011name = tostring(name)\015\n\011val = tostring(val)\015\n\011if settings[ident] then settings[ident][name]=val\015\n\011else settings[ident]={[name]=val} end\015\n\011save_last()\015\nend\015\n--Get a previously saved value, if it has one\015\nfunction MANAGER.getsetting(ident,name)\015\n\011if settings[ident] then return settings[ident][name] end\015\n\011return nil\015\nend\015\n--delete a setting, leave name nil to delete all of ident\015\nfunction MANAGER.delsetting(ident,name)\015\n\011if settings[ident] then\015\n\011if name then settings[ident][name]=nil\015\n\011else settings[ident]=nil end\015\n\011save_last()\015\n\011end\015\nend\015\n\015\n--mniip's download thing (mostly)\015\nlocal pattern = \"http://w*%.?(.-)(/.*)\"\015\nfunction download_file(url)\015\n\011local _,_,host,rest = url:find(pattern)\015\n\011if not host or not rest then MANAGER.print(\"Bad link\") return end\015\n\011local conn=socket.tcp()\015\n\011if not conn then return end\015\n\011local succ=pcall(conn.connect,conn,host,80)\015\n\011conn:settimeout(5)\015\n\011if not succ then return end\015\n\011local userAgent = \"PowderToy/\"..tpt.version.major..\".\"..tpt.version.minor..\".\"..tpt.version.build..\" (\"..((OS == \"WIN32\" or OS == \"WIN64\") and \"WIN; \" or (os == \"MACOSX\" and \"OSX; \" or \"LIN; \"))..(jacobsmod and \"M1\" or \"M0\")..\") SCRIPT/\"..MANAGER.version\015\n\011succ,resp,something=pcall(conn.send,conn,\"GET \"..rest..\" HTTP/1.1\\r\\nHost: \"..host..\"\\r\\nConnection: close\\r\\nUser-Agent: \"..userAgent..\"\\r\\n\\r\\n\")\015\n\011if not succ then return end\015\n\011local data=\"\"\015\n\011local c=\"\"\015\n\011while c do\015\n\011\011c=conn:receive(\"*l\")\015\n\011\011if c then\015\n\011\011\011data=data..\"\\n\"..c\015\n\011\011end\015\n\011end\015\n\011if data==\"\" then MANAGER.print(\"no data\") return end\015\n\011local first,last,code = data:find(\"HTTP/1%.1 (.-) .-\\n\")\015\n\011while last do\015\n\011\011data = data:sub(last+1)\015\n\011\011first,last,header = data:find(\"^([^\\n]-:.-)\\n\")\015\n\011\011--read something from headers?\015\n\011\011if header then\015\n\011\011\011if tonumber(code)==302 then\015\n\011\011\011\011local _,_,new = header:find(\"^Location: (.*)\")\015\n\011\011\011\011if new then return download_file(new) end\015\n\011\011\011end\015\n\011\011end\015\n\011end\015\n\011if host:find(\"pastebin.com\") then --pastebin adds some weird numbers\015\n\011\011_,_,data=data:find(\"\\n[^\\n]*\\n(.*)\\n.+\\n$\")\015\n\011end\015\n\011return data\015\nend\015\n--Downloads to a location\015\nlocal function download_script(ID,location)\015\n\011local file = download_file(\"http://starcatcher.us/scripts/main.lua?get=\"..ID)\015\n\011if file then\015\n\011\011f=io.open(location,\"w\")\015\n\011\011f:write(file)\015\n\011\011f:close()\015\n\011\011return true\015\n\011end\015\n\011return false\015\nend\015\n--Restart exe (if named correctly)\015\nlocal function do_restart()\015\n\011save_last()\015\n\011if platform then\015\n\011\011platform.restart()\015\n\011end\015\n\011if OS == \"WIN32\" or OS == \"WIN64\" then\015\n\011\011os.execute(\"TASKKILL /IM \\\"\"..EXE_NAME..\"\\\" /F &&START .\\\\\\\"\"..EXE_NAME..\"\\\"\")\015\n\011elseif OS == \"OSX\" then\015\n\011\011MANAGER.print(\"Can't restart on OS X when using game versions less than 91.0, please manually close and reopen The Powder Toy\")\015\n\011\011return\015\n\011else\015\n\011\011os.execute(\"killall -s KILL \\\"\"..EXE_NAME..\"\\\" && ./\\\"\"..EXE_NAME..\"\\\"\")\015\n\011end\015\n\011MANAGER.print(\"Restart failed, do you have the exe name right?\",255,0,0)\015\nend\015\nlocal function open_link(url)\015\n\011if platform then\015\n\011\011platform.openLink(url)\015\n\011else\015\n\011\011local command = (OS == \"WIN32\" or OS == \"WIN64\") and \"start\" or (OS == \"MACOSX\" and \"open\" or \"xdg-open\")\015\n\011\011os.execute(command..\" \"..url)\015\n\011end\015\nend\015\n--TPT interface\015\nlocal function step()\015\n\011if jacobsmod then\015\n\011\011tpt.fillrect(0,0,gfx.WIDTH,gfx.HEIGHT,0,0,0,150)\015\n\011else\015\n\011\011tpt.fillrect(-1,-1,gfx.WIDTH,gfx.HEIGHT,0,0,0,150)\015\n\011end\015\n\011mainwindow:draw()\015\n\011tpt.drawtext(280,140,\"Console Output:\")\015\n\011if requiresrestart then\015\n\011\011tpt.drawtext(280,88,\"Disabling a script requires a restart for effect!\",255,50,50)\015\n\011end\015\n\011tpt.drawtext(55,55,\"Click a script to toggle, hit DONE when finished\")\015\n\011tpt.drawtext(474,55,\"Script Manager v\"..MANAGER.version)--479 for simple versions\015\n\011tooltip:draw()\015\nend\015\nlocal function mouseclick(mousex,mousey,button,event,wheel)\015\n\011sidebutton:process(mousex,mousey,button,event,wheel)\015\n\011if MANAGER.hidden then return true end\015\n\015\n\011if mousex>612 or mousey>384 then return false end\015\n\011mainwindow:process(mousex,mousey,button,event,wheel)\015\n\011return false\015\nend\015\nlocal jacobsmod_old_menu_check = false\015\nlocal function keypress(key,nkey,modifier,event)\015\n\011if jacobsmod and (key == 'o' or nkey == 96) and event == 1 then jacobsmod_old_menu_check = true end\015\n\011if nkey==27 and not MANAGER.hidden then MANAGER.hidden=true return false end\015\n\011if MANAGER.hidden then return end\015\n\015\n\011if event == 1 then\015\n\011\011if key == \"[\" then\015\n\011\011\011mainwindow:process(mainwindow.x+30, mainwindow.y+30, 0, 2, 1)\015\n\011\011elseif key == \"]\" then\015\n\011\011\011mainwindow:process(mainwindow.x+30, mainwindow.y+30, 0, 2, -1)\015\n\011\011end\015\n\011end\015\n\011return false\015\nend\015\n--small button on right to bring up main menu\015\nlocal WHITE = {50,50,255,255}\015\nlocal BLACK = {0,0,255,255}\015\nlocal ICON = math.random(2) --pick a random icon\015\nlocal lua_letters= {{{2,2,2,7},{2,7,4,7},{6,7,6,11},{6,11,8,11},{8,7,8,11},{10,11,12,11},{10,11,10,15},{11,13,11,13},{12,11,12,15},},\015\n\011{{2,3,2,13},{2,14,7,14},{4,3,4,12},{4,12,7,12},{7,3,7,12},{9,3,12,3},{9,3,9,14},{10,8,11,8},{12,3,12,14},}}\015\nlocal function smallstep()\015\n\011gfx.drawRect(sidebutton.x, sidebutton.y+1, sidebutton.w+1, sidebutton.h+1,200,200,200)\015\n\011local color=WHITE\015\n\011if not MANAGER.hidden then\015\n\011\011step()\015\n\011\011gfx.fillRect(sidebutton.x, sidebutton.y+1, sidebutton.w+1, sidebutton.h+1)\015\n\011\011color=BLACK\015\n\011end\015\n\011for i,dline in ipairs(lua_letters[ICON]) do\015\n\011\011tpt.drawline(dline[1]+sidebutton.x,dline[2]+sidebutton.y,dline[3]+sidebutton.x,dline[4]+sidebutton.y,color[1],color[2],color[3])\015\n\011end\015\n\011if jacobsmod_old_menu_check then\015\n\011\011local ypos = 134\015\n\011\011if jacobsmod and tpt.oldmenu and tpt.oldmenu()==1 then\015\n\011\011\011ypos = 390\015\n\011\011elseif tpt.num_menus then\015\n\011\011\011ypos = 390-16*tpt.num_menus()-(not jacobsmod and 16 or 0)\015\n\011\011end\015\n\011\011sidebutton:onmove(0, ypos-sidebutton.y)\015\n\011\011jacobsmod_old_menu_check = false\015\n\011end\015\nend\015\n--button functions on click\015\nfunction ui_button.reloadpressed(self)\015\n\011load_filenames()\015\n\011load_downloaded()\015\n\011gen_buttons()\015\n\011mainwindow.checkbox:updatescroll()\015\n\011if num_files == 0 then\015\n\011\011MANAGER.print(\"No scripts found in '\"..TPT_LUA_PATH..\"' folder\",255,255,0)\015\n\011\011fs.makeDirectory(TPT_LUA_PATH)\015\n\011else\015\n\011\011MANAGER.print(\"Reloaded file list, found \"..num_files..\" scripts\")\015\n\011end\015\nend\015\nfunction ui_button.selectnone(self)\015\n\011for i,but in ipairs(mainwindow.checkbox.list) do\015\n\011\011but.selected = false\015\n\011end\015\nend\015\nfunction ui_button.consoleclear(self)\015\n\011mainwindow.menuconsole:clear()\015\nend\015\nfunction ui_button.changedir(self)\015\n\011local last = TPT_LUA_PATH\015\n\011local new = tpt.input(\"Change search directory\",\"Enter the folder where your scripts are\",TPT_LUA_PATH,TPT_LUA_PATH)\015\n\011if new~=last and new~=\"\" then\015\n\011\011fs.removeFile(last..PATH_SEP..\"autorunsettings.txt\")\015\n\011\011MANAGER.print(\"Directory changed to \"..new,255,255,0)\015\n\011\011TPT_LUA_PATH = new\015\n\011end\015\n\011ui_button.reloadpressed()\015\n\011save_last()\015\nend\015\nfunction ui_button.uploadscript(self)\015\n\011if not online then\015\n\011\011local command = (OS == \"WIN32\" or OS == \"WIN64\") and \"start\" or (OS == \"MACOSX\" and \"open\" or \"xdg-open\")\015\n\011\011os.execute(command..\" \"..TPT_LUA_PATH)\015\n\011else\015\n\011\011open_link(\"https://starcatcher.us/scripts/paste.lua\")\015\n\011end\015\nend\015\nlocal lastpaused\015\nfunction ui_button.sidepressed(self)\015\n\011if TPTMP and TPTMP.chatHidden == false then print(\"minimize TPTMP before opening the manager\") return end\015\n\011MANAGER.hidden = not MANAGER.hidden\015\n\011ui_button.localview()\015\n\011if not MANAGER.hidden then\015\n\011\011lastpaused = tpt.set_pause()\015\n\011\011tpt.set_pause(1)\015\n\011\011ui_button.reloadpressed()\015\n\011else\015\n\011\011tpt.set_pause(lastpaused)\015\n\011end\015\nend\015\nlocal donebutton\015\nfunction ui_button.donepressed(self)\015\n\011MANAGER.hidden = true\015\n\011for i,but in ipairs(mainwindow.checkbox.list) do\015\n\011\011local filepath = but.ID and localscripts[but.ID][\"path\"] or but.t.text\015\n\011\011if but.selected then\015\n\011\011\011if requiresrestart then\015\n\011\011\011\011running[filepath] = true\015\n\011\011\011else\015\n\011\011\011\011if not running[filepath] then\015\n\011\011\011\011\011local status,err = pcall(dofile,TPT_LUA_PATH..PATH_SEP..filepath)\015\n\011\011\011\011\011if not status then\015\n\011\011\011\011\011\011MANAGER.print(err,255,0,0)\015\n\011\011\011\011\011\011print(err)\015\n\011\011\011\011\011\011but.selected = false\015\n\011\011\011\011\011else\015\n\011\011\011\011\011\011MANAGER.print(\"Started \"..filepath)\015\n\011\011\011\011\011\011running[filepath] = true\015\n\011\011\011\011\011end\015\n\011\011\011\011end\015\n\011\011\011end\015\n\011\011elseif running[filepath] then\015\n\011\011\011running[filepath] = nil\015\n\011\011end\015\n\011end\015\n\011if requiresrestart then do_restart() return end\015\n\011save_last()\015\nend\015\nfunction ui_button.downloadpressed(self)\015\n\011for i,but in ipairs(mainwindow.checkbox.list) do\015\n\011\011if but.selected then\015\n\011\011\011--maybe do better display names later\015\n\011\011\011local displayName\015\n\011\011\011local function get_script(butt)\015\n\011\011\011\011local script = download_file(\"http://starcatcher.us/scripts/main.lua?get=\"..butt.ID)\015\n\011\011\011\011displayName = \"downloaded\"..PATH_SEP..butt.ID..\" \"..onlinescripts[butt.ID].author:gsub(\"[^%w _-]\", \"_\")..\"-\"..onlinescripts[butt.ID].name:gsub(\"[^%w _-]\", \"_\")..\".lua\"\015\n\011\011\011\011local name = TPT_LUA_PATH..PATH_SEP..displayName\015\n\011\011\011\011if not fs.exists(TPT_LUA_PATH..PATH_SEP..\"downloaded\") then\015\n\011\011\011\011\011fs.makeDirectory(TPT_LUA_PATH..PATH_SEP..\"downloaded\")\015\n\011\011\011\011end\015\n\011\011\011\011local file = io.open(name, \"w\")\015\n\011\011\011\011if not file then error(\"could not open \"..name) end\015\n\011\011\011\011file:write(script)\015\n\011\011\011\011file:close()\015\n\011\011\011\011if localscripts[butt.ID] and localscripts[butt.ID][\"path\"] ~= displayName then\015\n\011\011\011\011\011local oldpath = localscripts[butt.ID][\"path\"]\015\n\011\011\011\011\011fs.removeFile(TPT_LUA_PATH..\"/\"..oldpath:gsub(\"\\\\\",\"/\"))\015\n\011\011\011\011\011running[oldpath] = nil\015\n\011\011\011\011end\015\n\011\011\011\011localscripts[butt.ID] = onlinescripts[butt.ID]\015\n\011\011\011\011localscripts[butt.ID][\"path\"] = displayName\015\n\011\011\011\011dofile(name)\015\n\011\011\011end\015\n\011\011\011local status,err = pcall(get_script, but)\015\n\011\011\011if not status then\015\n\011\011\011\011MANAGER.print(err,255,0,0)\015\n\011\011\011\011print(err)\015\n\011\011\011\011but.selected = false\015\n\011\011\011else\015\n\011\011\011\011MANAGER.print(\"Downloaded and started \"..but.t.text)\015\n\011\011\011\011running[displayName] = true\015\n\011\011\011end\015\n\011\011end\015\n\011end\015\n\011MANAGER.hidden = true\015\n\011ui_button.localview()\015\n\011save_last()\015\nend\015\n\015\nfunction ui_button.pressed(self)\015\n\011self.selected = not self.selected\015\nend\015\nfunction ui_button.delete(self)\015\n\011--there is no tpt.confirm() yet\015\n\011if tpt.input(\"Delete File\", \"Delete \"..self.t.text..\"?\", \"yes\", \"no\") == \"yes\" then\015\n\011\011local filepath = self.ID and localscripts[self.ID][\"path\"] or self.t.text\015\n\011\011fs.removeFile(TPT_LUA_PATH..\"/\"..filepath:gsub(\"\\\\\",\"/\"))\015\n\011\011if running[filepath] then running[filepath] = nil end\015\n\011\011if localscripts[self.ID] then localscripts[self.ID] = nil end\015\n\011\011save_last()\015\n\011\011ui_button.localview()\015\n\011\011load_filenames()\015\n\011\011gen_buttons()\015\n\011end\015\nend\015\nfunction ui_button.viewonline(self)\015\n\011open_link(\"https://starcatcher.us/scripts?view=\"..self.ID)\015\nend\015\nfunction ui_button.scriptcheck(self)\015\n\011local oldpath = localscripts[self.ID][\"path\"]\015\n\011local newpath = \"downloaded\"..PATH_SEP..self.ID..\" \"..onlinescripts[self.ID].author:gsub(\"[^%w _-]\", \"_\")..\"-\"..onlinescripts[self.ID].name:gsub(\"[^%w _-]\", \"_\")..\".lua\"\015\n\011if download_script(self.ID,TPT_LUA_PATH..PATH_SEP..newpath) then\015\n\011\011self.canupdate = false\015\n\011\011localscripts[self.ID] = onlinescripts[self.ID]\015\n\011\011localscripts[self.ID][\"path\"] = newpath\015\n\011\011if oldpath:gsub(\"\\\\\",\"/\") ~= newpath:gsub(\"\\\\\",\"/\") then\015\n\011\011\011fs.removeFile(TPT_LUA_PATH..\"/\"..oldpath:gsub(\"\\\\\",\"/\"))\015\n\011\011\011if running[oldpath] then\015\n\011\011\011\011running[newpath],running[oldpath] = running[oldpath],nil\015\n\011\011\011end\015\n\011\011end\015\n\011\011if running[newpath] then\015\n\011\011\011do_restart()\015\n\011\011else\015\n\011\011\011save_last()\015\n\011\011\011MANAGER.print(\"Updated \"..onlinescripts[self.ID][\"name\"])\015\n\011\011end\015\n\011end\015\nend\015\nfunction ui_button.doupdate(self)\015\n\011if jacobsmod and jacobsmod >= 30 then\015\n\011\011fileSystem.move(\"scriptmanager.lua\", \"scriptmanagerold.lua\")\015\n\011\011download_script(1, 'scriptmanager.lua')\015\n\011else\015\n\011\011fileSystem.move(\"autorun.lua\", \"autorunold.lua\")\015\n\011\011download_script(1, 'autorun.lua')\015\n\011end\015\n\011localscripts[1] = updatetable[1]\015\n\011do_restart()\015\nend\015\nlocal uploadscriptbutton\015\nfunction ui_button.localview(self)\015\n\011if online then\015\n\011\011online = false\015\n\011\011gen_buttons()\015\n\011\011donebutton.t.text = \"DONE\"\015\n\011\011donebutton.w = 29 donebutton.x2 = donebutton.x + donebutton.w\015\n\011\011donebutton.f = ui_button.donepressed\015\n\011\011uploadscriptbutton.t.text = icons[\"folder\"]..\" Script Folder\"\015\n\011end\015\nend\015\nfunction ui_button.onlineview(self)\015\n\011if not online then\015\n\011\011online = true\015\n\011\011gen_buttons()\015\n\011\011donebutton.t.text = \"DOWNLOAD\"\015\n\011\011donebutton.w = 55 donebutton.x2 = donebutton.x + donebutton.w\015\n\011\011donebutton.f = ui_button.downloadpressed\015\n\011\011uploadscriptbutton.t.text = \"Upload Script\"\015\n\011end\015\nend\015\n--add buttons to window\015\ndonebutton = ui_button.new(55,339,29,10,ui_button.donepressed,\"DONE\")\015\nmainwindow:add(donebutton)\015\nmainwindow:add(ui_button.new(134,339,40,10,ui_button.sidepressed,\"CANCEL\"))\015\n--mainwindow:add(ui_button.new(152,339,29,10,ui_button.selectnone,\"NONE\"))\015\nlocal nonebutton = ui_button.new(62,81,8,8,ui_button.selectnone,\"\")\015\nnonebutton.drawbox = true\015\nmainwindow:add(nonebutton)\015\nmainwindow:add(ui_button.new(538,339,33,10,ui_button.consoleclear,\"CLEAR\"))\015\nmainwindow:add(ui_button.new(278,67,39,10,ui_button.reloadpressed,\"RELOAD\"))\015\nmainwindow:add(ui_button.new(378,67,51,10,ui_button.changedir,\"Change dir\"))\015\nuploadscriptbutton = ui_button.new(478,67,79,10,ui_button.uploadscript, icons[\"folder\"]..\" Script Folder\")\015\nmainwindow:add(uploadscriptbutton)\015\nlocal tempbutton = ui_button.new(60, 65, 30, 10, ui_button.localview, \"Local\")\015\ntempbutton.drawbox = true\015\nmainwindow:add(tempbutton)\015\ntempbutton = ui_button.new(100, 65, 35, 10, ui_button.onlineview, \"Online\")\015\ntempbutton.drawbox = true\015\nmainwindow:add(tempbutton)\015\nlocal ypos = 134\015\nif jacobsmod and tpt.oldmenu and tpt.oldmenu()==1 then\015\n\011ypos = 390\015\nelseif tpt.num_menus then\015\n\011ypos = 390-16*tpt.num_menus()-(not jacobsmod and 16 or 0)\015\nend\015\nsidebutton = ui_button.new(gfx.WIDTH-16,ypos,14,15,ui_button.sidepressed,'')\015\n\015\nlocal function gen_buttons_local()\015\n\011local count = 0\015\n\011local sorted = {}\015\n\011for k,v in pairs(localscripts) do if v.ID ~= 1 then table.insert(sorted, v) end end\015\n\011table.sort(sorted, function(first,second) return first.name:lower() < second.name:lower() end)\015\n\011for i,v in ipairs(sorted) do\015\n\011\011local check = mainwindow.checkbox:add(ui_button.pressed,ui_button.delete,v.name,true)\015\n\011\011check.ID = v.ID\015\n\011\011if running[v.path] then\015\n\011\011\011check.running = true\015\n\011\011\011check.selected = true\015\n\011\011end\015\n\011\011count = count + 1\015\n\011end\015\n\011if #sorted >= 5 and #filenames >= 5 then\015\n\011\011mainwindow.checkbox:add(nil, nil, \"\", false) --empty space to separate things\015\n\011end\015\n\011for i=1,#filenames do\015\n\011\011local check = mainwindow.checkbox:add(ui_button.pressed,ui_button.delete,filenames[i],true)\015\n\011\011if running[filenames[i]] then\015\n\011\011\011check.running = true\015\n\011\011\011check.selected = true\015\n\011\011end\015\n\011end\015\n\011num_files = count + #filenames\015\nend\015\nlocal function gen_buttons_online()\015\n\011local list = download_file(\"http://starcatcher.us/scripts/main.lua\")\015\n\011onlinescripts = readScriptInfo(list)\015\n\011local sorted = {}\015\n\011for k,v in pairs(onlinescripts) do table.insert(sorted, v) end\015\n\011table.sort(sorted, function(first,second) return first.ID < second.ID end)\015\n\011for k,v in pairs(sorted) do\015\n\011\011local check = mainwindow.checkbox:add(ui_button.pressed, ui_button.viewonline, v.name, false)\015\n\011\011check.ID = v.ID\015\n\011\011check.checkbut.ID = v.ID\015\n\011\011if localscripts[v.ID] then\015\n\011\011\011check.running = true\015\n\011\011\011if tonumber(v.version) > tonumber(localscripts[check.ID].version) then\015\n\011\011\011\011check.checkbut.canupdate = true\015\n\011\011\011end\015\n\011\011end\015\n\011end\015\n\011if first_online then\015\n\011\011first_online = false\015\n\011\011local updateinfo = download_file(\"http://starcatcher.us/scripts/main.lua?info=1\")\015\n\011\011updatetable = readScriptInfo(updateinfo)\015\n\011\011if not updatetable[1] then return end\015\n\011\011if tonumber(updatetable[1].version) > scriptversion then\015\n\011\011\011local updatebutton = ui_button.new(278,127,40,10,ui_button.doupdate,\"UPDATE\")\015\n\011\011\011updatebutton.t:setcolor(25,255,25)\015\n\011\011\011mainwindow:add(updatebutton)\015\n\011\011\011MANAGER.print(\"A script manager update is available! Click UPDATE\",25,255,55)\015\n\011\011\011MANAGER.print(updatetable[1].changelog,25,255,55)\015\n\011\011end\015\n\011end\015\nend\015\ngen_buttons = function()\015\n\011mainwindow.checkbox:clear()\015\n\011if online then\015\n\011\011gen_buttons_online()\015\n\011else\015\n\011\011gen_buttons_local()\015\n\011end\015\n\011mainwindow.checkbox:updatescroll()\015\nend\015\ngen_buttons()\015\n\015\n--register manager first\015\ntpt.register_step(smallstep)\015\n--load previously running scripts\015\nlocal started = \"\"\015\nfor prev,v in pairs(running) do\015\n\011local status,err = pcall(dofile,TPT_LUA_PATH..PATH_SEP..prev)\015\n\011if not status then\015\n\011\011MANAGER.print(err,255,0,0)\015\n\011\011running[prev] = nil\015\n\011else\015\n\011\011started=started..\" \"..prev\015\n\011\011local newbut = mainwindow.checkbox:add(ui_button.pressed,prev,nil,false)\015\n\011\011newbut.selected=true\015\n\011end\015\nend\015\nsave_last()\015\nif started~=\"\" then\015\n\011MANAGER.print(\"Auto started\"..started)\015\nend\015\ntpt.register_mouseevent(mouseclick)\015\ntpt.register_keypress(keypress)\015\n\015\n\015\n--Cracker64's Powder Toy Multiplayer\015\n--I highly recommend to use my Autorun Script Manager\015\n\015\nlocal versionstring = \"0.101\"\015\n\015\n--TODO's\015\n--FIGH,STKM,STK2,LIGH need a few more creation adjustments\015\n--Some more server functions\015\n-------------------------------------------------------\015\n\015\n--CHANGES:\015\n--Lots of Fixes\015\n--More colors!\015\n--ESC key will unfocus, then minimize chat\015\n--Changes from jacob, including: Support jacobsMod, keyrepeat\015\n--Support replace mode\015\n\015\nif TPTMP then if TPTMP.version <= 4 then TPTMP.disableMultiplayer() else error(\"newer version already running\") end end local get_name = tpt.get_name -- if script already running, replace it\015\nTPTMP = {[\"version\"] = 4, [\"versionStr\"] = versionstring} -- script version sent on connect to ensure server protocol is the same\015\nlocal issocket,socket = pcall(require,\"socket\")\015\nif not sim.clearRect then error\"Tpt version not supported\" end\015\nlocal using_manager = false\015\nlocal type = type -- people like to overwrite this function with a global a lot\015\nlocal _print = print\015\nif MANAGER ~= nil or MANAGER_EXISTS then\015\n\011using_manager = true\015\n\011_print = MANAGER and MANAGER.print or MANAGER_PRINT\015\nelse\015\n\011_print = print\015\nend\015\nlocal hooks_enabled = false --hooks only enabled once you maximize the button\015\n\015\nlocal PORT = 34403 --Change 34403 to your desired port\015\nlocal KEYBOARD = 1 --only change if you have issues. Only other option right now is 2(finnish).\015\n--Local player vars we need to keep\015\nlocal L = {mousex=0, mousey=0, realMouseX=0, realMouseY=0, brushx=0, brushy=0, sell=1, sela=296, selr=0, selrep=0, replacemode = 0, mButt=0, mEvent=0, isDrawing=false, dcolour=0, stick2=false, chatHidden=true, flashChat=false,\015\nshift=false, alt=false, ctrl=false, tabs = false, z=false, skipClick=false, pauseNextFrame=false, copying=false, stamp=false, placeStamp=false, lastStamp=nil, lastCopy=nil, smoved=false, rotate=false, sendScreen=false}\015\n\015\nlocal tptversion = tpt.version.build\015\nlocal jacobsmod = tpt.version.jacob1s_mod~=nil\015\nmath.randomseed(os.time())\015\nlocal username = get_name()\015\nif username == \"\" then\015\n\011username = \"Guest\"..math.random(10000,99999)\015\nend\015\nlocal chatwindow\015\nlocal con = {connected = false,\015\n\011\011 socket = nil,\015\n\011\011 members = nil,\015\n\011\011 pingTime = os.time()+60}\015\nlocal function disconnected(reason)\015\n\011if con.socket then\015\n\011\011con.socket:close()\015\n\011end\015\n\011if reason then\015\n\011\011chatwindow:addline(reason,255,50,50)\015\n\011else\015\n\011\011chatwindow:addline(\"Connection was closed\",255,50,50)\015\n\011end\015\n\011con.connected = false\015\n\011con.members = {}\015\nend\015\nlocal function conSend(cmd,msg,endNull)\015\n\011if not con.connected then return false,\"Not connected\" end\015\n\011msg = msg or \"\"\015\n\011if endNull then msg = msg..\"\\0\" end\015\n\011if cmd then msg = string.char(cmd)..msg end\015\n\011con.socket:settimeout(10)\015\n\011con.socket:send(msg)\015\n\011con.socket:settimeout(0)\015\nend\015\nlocal function joinChannel(chan)\015\n\011conSend(16,chan,true)\015\n\011--send some things to new channel\015\n\011conSend(34,string.char(L.brushx,L.brushy))\015\n\011conSend(37,string.char(math.floor(L.sell/256),L.sell%256))\015\n\011conSend(37,string.char(math.floor(64 + L.sela/256),L.sela%256))\015\n\011conSend(37,string.char(math.floor(128 + L.selr/256),L.selr%256))\015\n\011conSend(37,string.char(math.floor(192 + L.selrep/256),L.selrep%256))\015\n\011conSend(38,L.replacemode)\015\n\011conSend(65,string.char(math.floor(L.dcolour/16777216),math.floor(L.dcolour/65536)%256,math.floor(L.dcolour/256)%256,L.dcolour%256))\015\nend\015\nlocal function connectToServer(ip,port,nick)\015\n\011if con.connected then return false,\"Already connected\" end\015\n\011ip = ip or \"tptmp.starcatcher.us\"\015\n\011port = port or PORT\015\n\011local sock = socket.tcp()\015\n\011sock:settimeout(10)\015\n\011local s,r = sock:connect(ip,port)\015\n\011if not s then return false,r end\015\n\011sock:settimeout(0)\015\n\011sock:setoption(\"keepalive\",true)\015\n\011sock:send(string.char(tpt.version.major)..string.char(tpt.version.minor)..string.char(TPTMP.version)..nick..\"\\0\")\015\n\011local c,r\015\n\011while not c do\015\n\011c,r = sock:receive(1)\015\n\011if not c and r~=\"timeout\" then break end\015\n\011end\015\n\011if not c and r~=\"timeout\" then return false,r end\015\n\015\n\011if c~= \"\\1\" then\015\n\011if c==\"\\0\" then\015\n\011\011local err=\"\"\015\n\011\011c,r = sock:receive(1)\015\n\011\011while c~=\"\\0\" do\015\n\011\011err = err..c\015\n\011\011c,r = sock:receive(1)\015\n\011\011end\015\n\011\011if err==\"This nick is already on the server\" then\015\n\011\011\011nick = nick:gsub(\"(.)$\",function(s) local n=tonumber(s) if n and n+1 <= 9 then return n+1 else return nick:sub(-1)..'0' end end)\015\n\011\011\011return connectToServer(ip,port,nick)\015\n\011\011end\015\n\011\011return false,err\015\n\011end\015\n\011return false,\"Bad Connect\"\015\n\011end\015\n\015\n\011con.socket = sock\015\n\011con.connected = true\015\n\011username = nick\015\n\011conSend(34,string.char(L.brushx,L.brushy))\015\n\011conSend(37,string.char(math.floor(L.sell/256),L.sell%256))\015\n\011conSend(37,string.char(math.floor(64 + L.sela/256),L.sela%256))\015\n\011conSend(37,string.char(math.floor(128 + L.selr/256),L.selr%256))\015\n\011conSend(37,string.char(math.floor(192 + L.selrep/256),L.selrep%256))\015\n\011conSend(38,L.replacemode)\015\n\011conSend(65,string.char(math.floor(L.dcolour/16777216),math.floor(L.dcolour/65536)%256,math.floor(L.dcolour/256)%256,L.dcolour%256))\015\n\011return true\015\nend\015\n--get up to a null (\\0)\015\nlocal function conGetNull()\015\n\011con.socket:settimeout(nil)\015\n\011local c,r = con.socket:receive(1)\015\n\011if not c and r ~= \"timeout\" then disconnected() return nil end\015\n\011local rstring=\"\"\015\n\011while c~=\"\\0\" do\015\n\011rstring = rstring..c\015\n\011c,r = con.socket:receive(1)\015\n\011if not c and r ~= \"timeout\" then disconnected() return nil end\015\n\011end\015\n\011con.socket:settimeout(0)\015\n\011return rstring\015\nend\015\n--get next char/byte\015\nlocal function cChar()\015\n\011con.socket:settimeout(nil)\015\n\011local c,r = con.socket:receive(1)\015\n\011con.socket:settimeout(0)\015\n\011if not c then disconnected() end\015\n\011return c\015\nend\015\nlocal function cByte()\015\n\011local byte = cChar()\015\n\011return byte and byte:byte() or nil\015\nend\015\n--return table of arguments\015\nlocal function getArgs(msg)\015\n\011if not msg then return {} end\015\n\011local args = {}\015\n\011for word in msg:gmatch(\"([^%s%c]+)\") do\015\n\011table.insert(args,word)\015\n\011end\015\n\011return args\015\nend\015\n\015\nlocal ui_base local ui_box local ui_text local ui_button local ui_scrollbar local ui_inputbox local ui_chatbox\015\nui_base = {\015\nnew = function()\015\n\011local b={}\015\n\011b.drawlist = {}\015\n\011function b:drawadd(f)\015\n\011\011table.insert(self.drawlist,f)\015\n\011end\015\n\011function b:draw(...)\015\n\011\011for _,f in ipairs(self.drawlist) do\015\n\011\011\011if type(f)==\"function\" then\015\n\011\011\011\011f(self,...)\015\n\011\011\011end\015\n\011\011end\015\n\011end\015\n\011b.movelist = {}\015\n\011function b:moveadd(f)\015\n\011\011table.insert(self.movelist,f)\015\n\011end\015\n\011function b:onmove(x,y)\015\n\011\011for _,f in ipairs(self.movelist) do\015\n\011\011\011if type(f)==\"function\" then\015\n\011\011\011\011f(self,x,y)\015\n\011\011\011end\015\n\011\011end\015\n\011end\015\n\011return b\015\nend\015\n}\015\nui_box = {\015\nnew = function(x,y,w,h,r,g,b)\015\n\011local box=ui_base.new()\015\n\011box.x=x box.y=y box.w=w box.h=h box.x2=x+w box.y2=y+h\015\n\011box.r=0 box.g=0 box.b=b or 255\015\n\011function box:setcolor(r,g,b) self.r=r self.g=g self.b=b end\015\n\011function box:setbackground(r,g,b,a) self.br=r self.bg=g self.bb=b self.ba=a end\015\n\011box.drawbox=true\015\n\011box.drawbackground=false\015\n\011box:drawadd(function(self) if self.drawbackground then gfx.fillRect(self.x,self.y,self.w+1,self.h+1,self.br,self.bg,self.bb,self.ba) end\015\n\011\011\011\011\011\011\011\011if self.drawbox then gfx.drawRect(self.x,self.y,self.w+1,self.h+1,self.r,self.g,self.b) end end)\015\n\011box:moveadd(function(self,x,y)\015\n\011\011if x then self.x=self.x+x self.x2=self.x2+x end\015\n\011\011if y then self.y=self.y+y self.y2=self.y2+y end\015\n\011end)\015\n\011return box\015\nend\015\n}\015\nui_text = {\015\nnew = function(text,x,y,r,g,b)\015\n\011local txt = ui_base.new()\015\n\011txt.text = text\015\n\011txt.x=x or 0 txt.y=y or 0 txt.r=r or 255 txt.g=g or 255 txt.b=b or 255\015\n\011function txt:setcolor(r,g,b) self.r=r self.g=g self.b=b end\015\n\011txt:drawadd(function(self,x,y) gfx.drawText(x or self.x,y or self.y,self.text,self.r,self.g,self.b) end)\015\n\011txt:moveadd(function(self,x,y)\015\n\011\011if x then self.x=self.x+x end\015\n\011\011if y then self.y=self.y+y end\015\n\011end)\015\n\011return txt\015\nend,\015\n--Scrolls while holding mouse over\015\nnewscroll = function(text,x,y,vis,force,r,g,b)\015\n\011local txt = ui_text.new(text,x,y,r,g,b)\015\n\011if not force and tpt.textwidth(text)<vis then return txt end\015\n\011txt.visible=vis\015\n\011txt.length=string.len(text)\015\n\011txt.start=1\015\n\011local last=2\015\n\011while tpt.textwidth(text:sub(1,last))<vis and last<=txt.length do\015\n\011\011last=last+1\015\n\011end\015\n\011txt.last=last-1\015\n\011txt.minlast=last-1\015\n\011txt.ppl=((txt.visible-6)/(txt.length-txt.minlast+1))\015\n\011function txt:update(text,pos)\015\n\011\011if text then\015\n\011\011\011self.text=text\015\n\011\011\011self.length=string.len(text)\015\n\011\011\011local last=2\015\n\011\011\011while tpt.textwidth(text:sub(1,last))<self.visible and last<=self.length do\015\n\011\011\011\011last=last+1\015\n\011\011\011end\015\n\011\011\011self.minlast=last-1\015\n\011\011\011self.ppl=((self.visible-6)/(self.length-self.minlast+1))\015\n\011\011\011if not pos then self.last=self.minlast end\015\n\011\011end\015\n\011\011if pos then\015\n\011\011\011if pos>=self.last and pos<=self.length then --more than current visible\015\n\011\011\011\011local newlast = pos\015\n\011\011\011\011local newstart=1\015\n\011\011\011\011while tpt.textwidth(self.text:sub(newstart,newlast))>= self.visible do\015\n\011\011\011\011\011newstart=newstart+1\015\n\011\011\011\011end\015\n\011\011\011\011self.start=newstart self.last=newlast\015\n\011\011\011elseif pos<self.start and pos>0 then --position less than current visible\015\n\011\011\011\011local newstart=pos\015\n\011\011\011\011local newlast=pos+1\015\n\011\011\011\011while tpt.textwidth(self.text:sub(newstart,newlast))<self.visible and newlast<self.length do\015\n\011\011\011\011\011\011newlast=newlast+1\015\n\011\011\011\011end\015\n\011\011\011\011self.start=newstart self.last=newlast-1\015\n\011\011\011end\015\n\011\011\011--keep strings as long as possible (pulls from left)\015\n\011\011\011local newlast=self.last\015\n\011\011\011if newlast<self.minlast then newlast=self.minlast end\015\n\011\011\011local newstart=1\015\n\011\011\011while tpt.textwidth(self.text:sub(newstart,newlast))>= self.visible do\015\n\011\011\011\011\011newstart=newstart+1\015\n\011\011\011end\015\n\011\011\011self.start=newstart self.last=newlast\015\n\011\011end\015\n\011end\015\n\011txt.drawlist={} --reset draw\015\n\011txt:drawadd(function(self,x,y)\015\n\011\011gfx.drawText(x or self.x,y or self.y, self.text:sub(self.start,self.last) ,self.r,self.g,self.b)\015\n\011end)\015\n\011function txt:mouseMove(mx,my,dX,dY)\015\n\011\011local newlast = math.floor((mx-self.x)/self.ppl)+self.minlast\015\n\011\011if newlast<self.minlast then newlast=self.minlast end\015\n\011\011if newlast>0 and newlast~=self.last then\015\n\011\011\011local newstart=1\015\n\011\011\011while tpt.textwidth(self.text:sub(newstart,newlast))>= self.visible do\015\n\011\011\011\011newstart=newstart+1\015\n\011\011\011end\015\n\011\011\011self.start=newstart self.last=newlast\015\n\011\011end\015\n\011end\015\n\011return txt\015\nend\015\n}\015\nui_inputbox = {\015\nnew=function(x,y,w,h)\015\n\011local intext=ui_box.new(x,y,w,h)\015\n\011intext.cursor=0\015\n\011intext.line=1\015\n\011intext.currentline = \"\"\015\n\011intext.focus=false\015\n\011intext.t=ui_text.newscroll(\"\",x+2,y+2,w-2,true)\015\n\011intext.history={}\015\n\011intext.max_history=200\015\n\011intext.ratelimit = 0\015\n\011intext:drawadd(function(self)\015\n\011\011local cursoradjust=tpt.textwidth(self.t.text:sub(self.t.start,self.cursor))+2\015\n\011\011gfx.drawLine(self.x+cursoradjust,self.y,self.x+cursoradjust,self.y+10,255,255,255)\015\n\011\011self.t:draw()\015\n\011end)\015\n\011intext:moveadd(function(self,x,y) self.t:onmove(x,y) end)\015\n\011function intext:setfocus(focus)\015\n\011\011self.focus=focus\015\n\011\011if focus then self:setcolor(255,255,0)\015\n\011\011else self:setcolor(255,255,255) end\015\n\011end\015\n\011function intext:movecursor(amt)\015\n\011\011self.cursor = self.cursor+amt\015\n\011\011if self.cursor>self.t.length then self.cursor = self.t.length end\015\n\011\011if self.cursor<0 then self.cursor = 0 return end\015\n\011end\015\n\011function intext:addhistory(str)\015\n\011\011self.history[#self.history+1] = str\015\n\011\011if #self.history >= self.max_history then\015\n\011\011\011table.remove(self.history, 1)\015\n\011\011end\015\n\011end\015\n\011function intext:moveline(amt)\015\n\011\011self.line = self.line+amt\015\n\011\011local max = #self.currentline and #self.history+2 or #self.history+1\015\n\011\011if self.line>max then self.line=max\015\n\011\011elseif self.line<1 then self.line=1 end\015\n\011\011local history = self.history[self.line] or \"\"\015\n\011\011if self.line == #self.history+1 then history = self.currentline end\015\n\011\011self.cursor = string.len(history)\015\n\011\011self.t:update(history, self.cursor)\015\n\011end\015\n\011function intext:keypress(key, scan, rep, shift, ctrl, alt)\015\n\011\011if not self.focus then\015\n\011\011\011if key == 13 then\015\n\011\011\011\011self:setfocus(true)\015\n\011\011\011end\015\n\011\011\011return\015\n\011\011end\015\n\011\011-- Esc\015\n\011\011if key == 27 then\015\n\011\011\011self:setfocus(false)\015\n\011\011-- Enter\015\n\011\011elseif key == 13 and not rep then\015\n\011\011\011if socket.gettime() < self.ratelimit then\015\n\011\011\011\011return\015\n\011\011\011end\015\n\011\011\011local text = self.t.text\015\n\011\011\011if text == \"\" then\015\n\011\011\011\011self:setfocus(false)\015\n\011\011\011else\015\n\011\011\011\011self.cursor = 0\015\n\011\011\011\011self.t.text = \"\"\015\n\011\011\011\011self:addhistory(text)\015\n\011\011\011\011self.line = #self.history + 1\015\n\011\011\011\011self.currentline = \"\"\015\n\011\011\011\011self.ratelimit = socket.gettime() + 1\015\n\011\011\011\011return text\015\n\011\011\011end\015\n\011\011-- Up\015\n\011\011elseif key == 1073741906 then\015\n\011\011\011if socket.gettime() < self.ratelimit then\015\n\011\011\011\011return\015\n\011\011\011end\015\n\011\011\011self:moveline(-1)\015\n\011\011-- Down\015\n\011\011elseif key == 1073741905 then\015\n\011\011\011self:moveline(1)\015\n\011\011-- Right\015\n\011\011elseif key == 1073741903 then\015\n\011\011\011self:movecursor(1)\015\n\011\011\011self.t:update(nil, self.cursor)\015\n\011\011-- Left\015\n\011\011elseif key == 1073741904 then\015\n\011\011\011self:movecursor(-1)\015\n\011\011\011self.t:update(nil, self.cursor)\015\n\011\011end\015\n\015\n\011\011local newstr\015\n\011\011-- Backspace\015\n\011\011if key == 8 then\015\n\011\011\011if self.cursor > 0 then\015\n\011\011\011\011newstr = self.t.text:sub(1,self.cursor-1) .. self.t.text:sub(self.cursor+1)\015\n\011\011\011\011self:movecursor(-1)\015\n\011\011\011end\015\n\011\011-- Delete\015\n\011\011elseif key == 127 then\015\n\011\011\011newstr=self.t.text:sub(1,self.cursor) .. self.t.text:sub(self.cursor+2)\015\n\011\011-- Tab\015\n\011\011elseif key == 9 then\015\n\011\011\011local nickstart, nickend, nick = self.t.text:sub(1,self.cursor+1):find(\"([^%s%c]+)\"..(self.cursor == #self.t.text and \"\" or \" \")..\"$\")\015\n\011\011\011if con.members and nick then\015\n\011\011\011\011for k, v in pairs(con.members) do\015\n\011\011\011\011\011if v.name:sub(1, #nick) == nick then\015\n\011\011\011\011\011\011nick = v.name\015\n\011\011\011\011\011\011if nickstart == 1 then\015\n\011\011\011\011\011\011\011nick = nick .. \":\"\015\n\011\011\011\011\011\011end\015\n\011\011\011\011\011\011newstr = self.t.text:sub(1,nickstart-1)..nick..\" \"..self.t.text:sub(nickend+1, #self.t.text)\015\n\011\011\011\011\011\011self.cursor = nickstart + #nick\015\n\011\011\011\011\011end\015\n\011\011\011\011end\015\n\011\011\011end\015\n\011\011end\015\n\011\011if newstr then\015\n\011\011\011self.t:update(newstr,self.cursor)\015\n\011\011end\015\n\011end\015\n\011function intext:textinput(text)\015\n\011\011if not self.focus then\015\n\011\011\011return\015\n\011\011end\015\n\011\011-- TPT font has no unicode characters at the moment, nor does it have a good enough api to support them\015\n\011\011if #text > 1 or string.byte(text) < 20 or string.byte(text) > 126 then return end\015\n\011\011newstr = self.t.text:sub(1, self.cursor) .. text .. self.t.text:sub(self.cursor + 1)\015\n\011\011self.currentline = newstr\015\n\011\011self.t:update(newstr, self.cursor + 1)\015\n\011\011self:movecursor(1)\015\n\011end\015\n\011return intext\015\nend\015\n}\015\nui_scrollbar = {\015\nnew = function(x,y,h,t,m)\015\n\011local bar = ui_base.new() --use line object as base?\015\n\011bar.x=x bar.y=y bar.h=h\015\n\011bar.total=t\015\n\011bar.numshown=m\015\n\011bar.pos=0\015\n\011bar.length=math.floor((1/math.ceil(bar.total-bar.numshown+1))*bar.h)\015\n\011bar.soffset=math.floor(bar.pos*((bar.h-bar.length)/(bar.total-bar.numshown)))\015\n\011function bar:update(total,shown,pos)\015\n\011\011self.pos=pos or 0\015\n\011\011if self.pos<0 then self.pos=0 end\015\n\011\011self.total=total\015\n\011\011self.numshown=shown\015\n\011\011self.length= math.floor((1/math.ceil(self.total-self.numshown+1))*self.h)\015\n\011\011self.soffset= math.floor(self.pos*((self.h-self.length)/(self.total-self.numshown)))\015\n\011end\015\n\011function bar:move(wheel)\015\n\011\011self.pos = self.pos-wheel\015\n\011\011if self.pos < 0 then self.pos=0 end\015\n\011\011if self.pos > (self.total-self.numshown) then self.pos=(self.total-self.numshown) end\015\n\011\011self.soffset= math.floor(self.pos*((self.h-self.length)/(self.total-self.numshown)))\015\n\011end\015\n\011bar:drawadd(function(self)\015\n\011\011if self.total > self.numshown then\015\n\011\011\011gfx.drawLine(self.x,self.y+self.soffset,self.x,self.y+self.soffset+self.length)\015\n\011\011end\015\n\011end)\015\n\011bar:moveadd(function(self,x,y)\015\n\011\011if x then self.x=self.x+x end\015\n\011\011if y then self.y=self.y+y end\015\n\011end)\015\n\011function bar:mouseWheel(mx,my,wheel)\015\n\011\011if wheel~=0 and not hidden_mode then\015\n\011\011\011if self.total > self.numshown then\015\n\011\011\011\011local previous = self.pos\015\n\011\011\011\011self:move(wheel)\015\n\011\011\011\011if self.pos~=previous then\015\n\011\011\011\011\011return wheel\015\n\011\011\011\011end\015\n\011\011\011end\015\n\011\011end\015\n\011end\015\n\011return bar\015\nend\015\n}\015\nui_button = {\015\nnew = function(x,y,w,h,f,text)\015\n\011local b = ui_box.new(x,y,w,h)\015\n\011b.f=f\015\n\011b.t=ui_text.new(text,x+2,y+2)\015\n\011b.drawbox=false\015\n\011b.clicked = false\015\n\011b.invert = false\015\n\011b:drawadd(function(self)\015\n\011\011if self.clicked or self.invert then\015\n\011\011\011tpt.fillrect(self.x,self.y,self.w,self.h)\015\n\011\011\011local tr=self.t.r local tg=self.t.g local tb=self.t.b\015\n\011\011\011b.t:setcolor(0,0,0)\015\n\011\011\011b.t:draw()\015\n\011\011\011b.t:setcolor(tr,tg,tb)\015\n\011\011else\015\n\011\011\011b.t:draw()\015\n\011\011end\015\n\011end)\015\n\011b:moveadd(function(self,x,y)\015\n\011\011self.t:onmove(x,y)\015\n\011end)\015\n\011function b:mouseDown(mouseX, mouseY, button, reason)\015\n\011\011if mouseX >= self.x and mouseX <= self.x2 and mouseY >= self.y and mouseY <= self.y2 then\015\n\011\011\011self.clicked = true\015\n\011\011\011return true\015\n\011\011end\015\n\011end\015\n\011function b:mouseMove(mouseX, mouseY, dX, dY)\015\n\011\011if not (mouseX >= self.x and mouseX <= self.x2 and mouseY >= self.y and mouseY <= self.y2) then\015\n\011\011\011self.clicked = false\015\n\011\011end\015\n\011end\015\n\011function b:mouseUp(mouseX, mouseY, button, reason)\015\n\011\011if self.clicked and mouseX >= self.x and mouseX <= self.x2 and mouseY >= self.y and mouseY <= self.y2 then\015\n\011\011\011self:f()\015\n\011\011\011return true\015\n\011\011end\015\n\011end\015\n\011return b\015\nend\015\n}\015\nui_chatbox = {\015\nnew=function(x,y,w,h)\015\n\011local chat=ui_box.new(x,y,w,h)\015\n\011chat.moving=false\015\n\011chat.lastx=0\015\n\011chat.lasty=0\015\n\011chat.relx=0\015\n\011chat.rely=0\015\n\011chat.shown_lines=math.floor(chat.h/10)-2 --one line for top, one for chat\015\n\011chat.max_width=chat.w-4\015\n\011chat.max_lines=200\015\n\011chat.lines = {}\015\n\011chat.scrollbar = ui_scrollbar.new(chat.x2-2,chat.y+11,chat.h-22,0,chat.shown_lines)\015\n\011chat.inputbox = ui_inputbox.new(x,chat.y2-10,w,10)\015\n\011chat.minimize = ui_button.new(chat.x2-15,chat.y,15,10,function() chat.moving=false chat.inputbox:setfocus(false) L.chatHidden=true TPTMP.chatHidden=true end,\">>\")\015\n\011chat:drawadd(function(self)\015\n\011\011if self.w > 175 and jacobsmod then\015\n\011\011\011gfx.drawText(self.x+self.w/2-tpt.textwidth(\"TPT Multiplayer, by cracker64\")/2,self.y+2,\"TPT Multiplayer, by cracker64\")\015\n\011\011elseif self.w > 100 then\015\n\011\011\011gfx.drawText(self.x+self.w/2-tpt.textwidth(\"TPT Multiplayer\")/2,self.y+2,\"TPT Multiplayer\")\015\n\011\011end\015\n\011\011gfx.drawLine(self.x+1,self.y+10,self.x2-1,self.y+10,120,120,120)\015\n\011\011self.scrollbar:draw()\015\n\011\011local count=0\015\n\011\011for i,line in ipairs(self.lines) do\015\n\011\011\011if i>self.scrollbar.pos and i<= self.scrollbar.pos+self.shown_lines then\015\n\011\011\011\011line:draw(self.x+3,self.y+12+(count*10))\015\n\011\011\011\011count = count+1\015\n\011\011\011end\015\n\011\011end\015\n\011\011self.inputbox:draw()\015\n\011\011self.minimize:draw()\015\n\011end)\015\n\011chat:moveadd(function(self,x,y)\015\n\011\011for i,line in ipairs(self.lines) do\015\n\011\011\011line:onmove(x,y)\015\n\011\011end\015\n\011\011self.scrollbar:onmove(x,y)\015\n\011\011self.inputbox:onmove(x,y)\015\n\011\011self.minimize:onmove(x,y)\015\n\011end)\015\n\011function chat:addline(line,r,g,b,noflash)\015\n\011\011if not line or line==\"\" then return end --No blank lines\015\n\011\011local linebreak,lastspace = 0,nil\015\n\011\011for i=0,#line do\015\n\011\011\011local width = tpt.textwidth(line:sub(linebreak,i+1))\015\n\011\011\011if width > self.max_width/2 and line:sub(i,i):match(\"[%s,_%.%-?!]\") then\015\n\011\011\011\011lastspace = i\015\n\011\011\011end\015\n\011\011\011if width > self.max_width or i==#line then\015\n\011\011\011\011local pos = (i==#line or not lastspace) and i or lastspace\015\n\011\011\011\011table.insert(self.lines,ui_text.new(line:sub(linebreak,pos),self.x,0,r,g,b))\015\n\011\011\011\011linebreak = pos+1\015\n\011\011\011\011lastspace = nil\015\n\011\011\011end\015\n\011\011end\015\n\011\011while #self.lines>self.max_lines do table.remove(self.lines,1) end\015\n\011\011self.scrollbar:update(#self.lines,self.shown_lines,#self.lines-self.shown_lines)\015\n\011\011if L.chatHidden and not noflash then L.flashChat=true end\015\n\011end\015\n\011chat:addline(\"TPTMP v\"..versionstring..\": Type '/connect' to join server, or /list for a list of commands.\",200,200,200,true)\015\n\011function chat:mouseDown(mouseX, mouseY, button)\015\n\011\011if L.chatHidden then return false end\015\n\011\011self.minimize:mouseDown(mouseX, mouseY, button)\015\n\011\011\015\n\011\011local selectedLine = math.floor((mouseY - self.y) / 10)\015\n\011\011-- Mouse outside chat window, defocus it\015\n\011\011if mouseX < self.x or mouseX > self.x2 or mouseY < self.y or mouseY > self.y2 then\015\n\011\011\011self.inputbox:setfocus(false)\015\n\011\011\011return false\015\n\011\011end\015\n\015\n\011\011-- header was grabbed, enable window movement\015\n\011\011if selectedLine == 0 and mouseX < self.minimize.x then\015\n\011\011\011self.moving = true\015\n\011\011\011self.lastx = mx\015\n\011\011\011self.lasty = my\015\n\011\011\011self.relx = mouseX - self.x\015\n\011\011\011self.rely = mouseY - self.y\015\n\011\011\011return true\015\n\011\011-- Textbox clicked\015\n\011\011elseif selectedLine == self.shown_lines + 1 then\015\n\011\011\011self.inputbox:setfocus(true)\015\n\011\011\011return true\015\n\011\011end\015\n\015\n\011\011-- At this point we know chatbox is selected, ensure window is focused then block mouse events\015\n\011\011if not self.inputbox.focus then\015\n\011\011\011self.inputbox:setfocus(true)\015\n\011\011end\015\n\011\011return true\015\n\011end\015\n\011function chat:mouseMove(mouseX, mouseY, dX, dY)\015\n\011\011if self.moving then\015\n\011\011\011local newx, newy = self.x + dX, self.y + dY\015\n\011\011\011if newx < 0 then dX = dX - newx end\015\n\011\011\011if newy < 0 then dY = dY - newy end\015\n\011\011\011if (newx + self.w) >= sim.XRES then dX = dX - (newx + self.w - sim.XRES) end\015\n\011\011\011if (newy + self.h) >= sim.YRES then dY = dY - (newy + self.h - sim.YRES) end\015\n\015\n\011\011\011if dX < 0 and mouseX > self.relx + self.x then dX = 0 end\015\n\011\011\011if dX > 0 and mouseX < self.relx + self.x then dX = 0 end\015\n\011\011\011if dY < 0 and mouseY > self.rely + self.y then dY = 0 end\015\n\011\011\011if dY > 0 and mouseY < self.rely + self.y then dY = 0 end\015\n\011\011\011\015\n\011\011\011self:onmove(dX, dY)\015\n\011\011end\015\n\011\011self.minimize:mouseMove(mouseX, mouseY, dX, dY)\015\n\011end\015\n\011function chat:mouseUp(mouseX, mouseY, button, reason)\015\n\011\011self.minimize:mouseUp(mouseX, mouseY, button, reason)\015\n\011\011if self.moving then\015\n\011\011\011self.moving = false\015\n\011\011\011return true\015\n\011\011end\015\n\011end\015\n\011function chat:mouseWheel(mouseX, mouseY, wheel)\015\n\011\011self.scrollbar:mouseWheel(mouseX, mouseY, wheel)\015\n\011end\015\n\011--commands for chat window\015\n\011chatcommands = {\015\n\011connect = function(self,msg,args)\015\n\011\011if not issocket then self:addline(\"No luasockets found\") return end\015\n\011\011local newname = pcall(string.dump, get_name) and \"Gue\"..\"st\"..math[\"random\"](1111,9888) or get_name()\015\n\011\011local s,r = connectToServer(args[1],tonumber(args[2]), newname~=\"\" and newname or username)\015\n\011\011if not s then self:addline(r,255,50,50) end\015\n\011\011pressedKeys = nil\015\n\011end,\015\n\011send = function(self,msg,args)\015\n\011\011if tonumber(args[1]) and args[2] then\015\n\011\011local withNull=false\015\n\011\011if args[2]==\"true\" then withNull=true end\015\n\011\011msg = msg:sub(#args[1]+1+(withNull and #args[2]+2 or 0))\015\n\011\011conSend(tonumber(args[1]),msg,withNull)\015\n\011\011end\015\n\011end,\015\n\011quit = function(self,msg,args)\015\n\011\011disconnected(\"Disconnected\")\015\n\011end,\015\n\011disconnect = function(self,msg,args)\015\n\011\011disconnected(\"Disconnected\")\015\n\011end,\015\n\011join = function(self,msg,args)\015\n\011\011if args[1] then\015\n\011\011\011joinChannel(args[1])\015\n\011\011\011self:addline(\"joined channel \"..args[1],50,255,50)\015\n\011\011end\015\n\011end,\015\n\011sync = function(self,msg,args)\015\n\011\011if con.connected then L.sendScreen=true end --need to send 67 clear screen\015\n\011\011self:addline(\"Synced screen to server\",255,255,50)\015\n\011end,\015\n\011help = function(self,msg,args)\015\n\011\011if not args[1] then self:addline(\"/help <command>, type /list for a list of commands\") end\015\n\011\011if args[1] == \"connect\" then self:addline(\"(/connect [ip] [port]) -- connect to a TPT multiplayer server, or no args to connect to the default one\")\015\n\011\011--elseif args[1] == \"send\" then self:addline(\"(/send <something> <somethingelse>) -- send raw data to the server\") -- send a raw command\015\n\011\011elseif args[1] == \"quit\" or args[1] == \"disconnect\" then self:addline(\"(/quit, no arguments) -- quit the game\")\015\n\011\011elseif args[1] == \"join\" then self:addline(\"(/join <channel> -- joins a room on the server\")\015\n\011\011elseif args[1] == \"sync\" then self:addline(\"(/sync, no arguments) -- syncs your screen to everyone else in the room\")\015\n\011\011elseif args[1] == \"me\" then self:addline(\"(/me <message>) -- say something in 3rd person\") -- send a raw command\015\n\011\011elseif args[1] == \"kick\" then self:addline(\"(/kick <nick> <reason>) -- kick a user, only works if you have been in a channel the longest\")\015\n\011\011elseif args[1] == \"size\" then self:addline(\"(/size <width> <height>) -- sets the size of the chat window\")\015\n\011\011end\015\n\011end,\015\n\011list = function(self,msg,args)\015\n\011\011local list = \"\"\015\n\011\011for name in pairs(chatcommands) do\015\n\011\011\011list=list..name..\", \"\015\n\011\011end\015\n\011\011self:addline(\"Commands: \"..list:sub(1,#list-2))\015\n\011end,\015\n\011me = function(self, msg, args)\015\n\011\011if not con.connected then return end\015\n\011\011self:addline(\"* \" .. username .. \" \".. table.concat(args, \" \"),200,200,200)\015\n\011\011conSend(20,table.concat(args, \" \"),true)\015\n\011end,\015\n\011kick = function(self, msg, args)\015\n\011\011if not con.connected then return end\015\n\011\011if not args[1] then self:addline(\"Need a nick! '/kick <nick> [reason]'\") return end\015\n\011\011conSend(21, args[1]..\"\\0\"..table.concat(args, \" \", 2),true)\015\n\011end,\015\n\011size = function(self, msg, args)\015\n\011\011if args[2] then\015\n\011\011\011local w, h = tonumber(args[1]), tonumber(args[2])\015\n\011\011\011if w < 75 or h < 50 then self:addline(\"size too small\") return\015\n\011\011\011elseif w > sim.XRES-100 or h > sim.YRES-100 then self:addline(\"size too large\") return\015\n\011\011\011end\015\n\011\011\011chatwindow = ui_chatbox.new(100,100,w,h)\015\n\011\011\011chatwindow:setbackground(10,10,10,235) chatwindow.drawbackground=true\015\n\011\011\011if using_manager then\015\n\011\011\011\011MANAGER.savesetting(\"tptmp\", \"width\", w)\015\n\011\011\011\011MANAGER.savesetting(\"tptmp\", \"height\", h)\015\n\011\011\011end\015\n\011\011end\015\n\011end\015\n\011}\015\n\011function chat:keypress(key, scan, rep, shift, ctrl, alt)\015\n\011\011if L.chatHidden then return nil end\015\n\011\011local text = self.inputbox:keypress(key, scan, rep, shift, ctrl, alt)\015\n\011\011if text and text~=\"\" then\015\n\011\011\011local cmd = text:match(\"^/([^%s]+)\")\015\n\011\011\011if cmd then\015\n\011\011\011\011local msg=text:sub(#cmd+3)\015\n\011\011\011\011local args = getArgs(msg)\015\n\011\011\011\011if chatcommands[cmd] then\015\n\011\011\011\011\011chatcommands[cmd](self,msg,args)\015\n\011\011\011\011\011--self:addline(\"Executed \"..cmd..\" \"..rest)\015\n\011\011\011\011\011return\015\n\011\011\011\011end\015\n\011\011\011end\015\n\011\011\011--normal chat\015\n\011\011\011if con.connected then\015\n\011\011\011\011conSend(19,text,true)\015\n\011\011\011\011self:addline(username .. \": \".. text,200,200,200)\015\n\011\011\011else\015\n\011\011\011\011self:addline(\"Not connected to server!\",255,50,50)\015\n\011\011\011end\015\n\011\011end\015\n\011\011if self.inputbox.focus then\015\n\011\011\011return true\015\n\011\011end\015\n\011end\015\n\011function chat:textinput(text)\015\n\011\011if L.chatHidden then return end\015\n\011\011self.inputbox:textinput(text)\015\n\011end\015\n\011return chat\015\nend\015\n}\015\nlocal fadeText = {}\015\n--A little text that fades away, (align text (left/center/right)?)\015\nlocal function newFadeText(text,frames,x,y,r,g,b,noremove)\015\n\011local t = {ticks=frames,max=frames,text=text,x=x,y=y,r=r,g=g,b=b,keep=noremove}\015\n\011t.reset = function(self,text) self.ticks=self.max if text then self.text=text end end\015\n\011table.insert(fadeText,t)\015\n\011return t\015\nend\015\n--Some text locations for repeated usage\015\nlocal infoText = newFadeText(\"\",150,245,370,255,255,255,true)\015\nlocal cmodeText = newFadeText(\"\",120,250,180,255,255,255,true)\015\n\015\nlocal function getypos()\015\n\011local ypos = 136\015\n\011if jacobsmod and tpt.oldmenu and tpt.oldmenu()==1 then\015\n\011\011ypos = 392\015\n\011elseif tpt.num_menus then\015\n\011\011ypos = 392-16*tpt.num_menus()-(not jacobsmod and 16 or 0)\015\n\011end\015\n\011if using_manager then ypos = ypos - 17 end\015\n\011return ypos\015\nend\015\nlocal jacobsmod_old_menu_check = false\015\nlocal showbutton = ui_button.new(613,getypos(),14,14,function() if using_manager and not MANAGER.hidden then _print(\"minimize the manager before opening TPTMP\") return end if not hooks_enabled then TPTMP.enableMultiplayer() end L.chatHidden=false TPTMP.chatHidden=false L.flashChat=false end,\"Mp\")\015\nlocal flashCount=0\015\nshowbutton.drawbox = true showbutton:drawadd(function(self) if L.flashChat then self.almostselected=true flashCount=flashCount+1 if flashCount%25==0 then self.invert=not self.invert end end end)\015\nif using_manager then\015\n\011local loadsettings = function() chatwindow = ui_chatbox.new(100, 100, tonumber(MANAGER.getsetting(\"tptmp\", \"width\")), tonumber(MANAGER.getsetting(\"tptmp\", \"height\"))) end\015\n\011if not pcall(loadsettings) then chatwindow = ui_chatbox.new(100, 100, 225, 150) end\015\nelse\015\n\011chatwindow = ui_chatbox.new(100, 100, 225, 150)\015\nend\015\nchatwindow:setbackground(10,10,10,235) chatwindow.drawbackground=true\015\n\015\nlocal eleNameTable = {\015\n[\"DEFAULT_PT_LIFE_GOL\"] = 256,[\"DEFAULT_PT_LIFE_HLIF\"] = 257,[\"DEFAULT_PT_LIFE_ASIM\"] = 258,[\"DEFAULT_PT_LIFE_2x2\"] = 259,[\"DEFAULT_PT_LIFE_DANI\"] = 260,\015\n[\"DEFAULT_PT_LIFE_AMOE\"] = 261,[\"DEFAULT_PT_LIFE_MOVE\"] = 262,[\"DEFAULT_PT_LIFE_PGOL\"] = 263,[\"DEFAULT_PT_LIFE_DMOE\"] = 264,[\"DEFAULT_PT_LIFE_34\"] = 265,\015\n[\"DEFAULT_PT_LIFE_LLIF\"] = 276,[\"DEFAULT_PT_LIFE_STAN\"] = 267,[\"DEFAULT_PT_LIFE_SEED\"] = 268,[\"DEFAULT_PT_LIFE_MAZE\"] = 269,[\"DEFAULT_PT_LIFE_COAG\"] = 270,\015\n[\"DEFAULT_PT_LIFE_WALL\"] = 271,[\"DEFAULT_PT_LIFE_GNAR\"] = 272,[\"DEFAULT_PT_LIFE_REPL\"] = 273,[\"DEFAULT_PT_LIFE_MYST\"] = 274,[\"DEFAULT_PT_LIFE_LOTE\"] = 275,\015\n[\"DEFAULT_PT_LIFE_FRG2\"] = 276,[\"DEFAULT_PT_LIFE_STAR\"] = 277,[\"DEFAULT_PT_LIFE_FROG\"] = 278,[\"DEFAULT_PT_LIFE_BRAN\"] = 279,\015\n--walls\015\n[\"DEFAULT_WL_ERASE\"] = 280,[\"DEFAULT_WL_CNDTW\"] = 281,[\"DEFAULT_WL_EWALL\"] = 282,[\"DEFAULT_WL_DTECT\"] = 283,[\"DEFAULT_WL_STRM\"] = 284,\015\n[\"DEFAULT_WL_FAN\"] = 285,[\"DEFAULT_WL_LIQD\"] = 286,[\"DEFAULT_WL_ABSRB\"] = 287,[\"DEFAULT_WL_WALL\"] = 288,[\"DEFAULT_WL_AIR\"] = 289,[\"DEFAULT_WL_POWDR\"] = 290,\015\n[\"DEFAULT_WL_CNDTR\"] = 291,[\"DEFAULT_WL_EHOLE\"] = 292,[\"DEFAULT_WL_GAS\"] = 293,[\"DEFAULT_WL_GRVTY\"] = 294,[\"DEFAULT_WL_ENRGY\"] = 295,\015\n[\"DEFAULT_WL_NOAIR\"] = 296,[\"DEFAULT_WL_ERASEA\"] = 297,[\"DEFAULT_WL_STASIS\"] = 298,\015\n--special tools\015\n[\"DEFAULT_UI_SAMPLE\"] = 299,[\"DEFAULT_UI_SIGN\"] = 300,[\"DEFAULT_UI_PROPERTY\"] = 301,[\"DEFAULT_UI_WIND\"] = 302,\015\n--tools\015\n[\"DEFAULT_TOOL_HEAT\"] = 303,[\"DEFAULT_TOOL_COOL\"] = 304,[\"DEFAULT_TOOL_AIR\"] = 305,[\"DEFAULT_TOOL_VAC\"] = 306,[\"DEFAULT_TOOL_PGRV\"] = 307,[\"DEFAULT_TOOL_NGRV\"] = 308, [\"DEFAULT_TOOL_MIX\"] = 309,\015\n--decoration tools\015\n[\"DEFAULT_DECOR_SET\"] = 310,[\"DEFAULT_DECOR_CLR\"] = 311,[\"DEFAULT_DECOR_ADD\"] = 312,[\"DEFAULT_DECOR_SUB\"] = 313,[\"DEFAULT_DECOR_MUL\"] = 314,[\"DEFAULT_DECOR_DIV\"] = 315,[\"DEFAULT_DECOR_SMDG\"] = 316,\015\n[\"DEFAULT_DECOR_LIGH\"] = 317, [\"DEFAULT_DECOR_DARK\"] = 318\015\n}\015\nlocal gravList= {[0]=\"Vertical\",[1]=\"Off\",[2]=\"Radial\"}\015\nlocal airList= {[0]=\"On\",[1]=\"Pressure Off\",[2]=\"Velocity Off\",[3]=\"Off\",[4]=\"No Update\"}\015\nlocal noFlood = {[15]=true,[55]=true,[87]=true,[128]=true,[158]=true}\015\nlocal noShape = {[55]=true,[87]=true,[128]=true,[158]=true}\015\nlocal createOverride = {\015\n\011[55] = function(rx,ry,c) return 0,0,c end,\015\n\011[87] = function(rx,ry,c) local tmp=rx+ry if tmp>55 then tmp=55 end return 0,0,c+bit.lshift(tmp,8) end,\015\n\011[88] = function(rx,ry,c) local tmp=rx*4+ry*4+7 if tmp>300 then tmp=300 end return rx,ry,c+bit.lshift(tmp,8) end,\015\n\011[128] = function(rx,ry,c) return 0,0,c end,\015\n\011[158] = function(rx,ry,c) return 0,0,c end}\015\nlocal golStart,golEnd=256,279\015\nlocal wallStart,wallEnd=280,298\015\nlocal toolStart,toolEnd=303,309\015\nlocal decoStart,decoEnd=310,318\015\n\015\n--Functions that do stuff in powdertoy\015\nlocal function createPartsAny(x,y,rx,ry,c,brush,user)\015\n\011if c>=wallStart then\015\n\011\011if c<= wallEnd then\015\n\011\011\011if c == 284 then rx,ry = 0,0 end\015\n\011\011\011sim.createWalls(x,y,rx,ry,c-wallStart,brush)\015\n\011\011elseif c<=toolEnd then\015\n\011\011\011if c>=toolStart then sim.toolBrush(x,y,rx,ry,c-toolStart,brush) end\015\n\011\011elseif c<= decoEnd then\015\n\011\011\011sim.decoBrush(x,y,rx,ry,user.dcolour[2],user.dcolour[3],user.dcolour[4],user.dcolour[1],c-decoStart,brush)\015\n\011\011end\015\n\011\011return\015\n\011elseif c>=golStart then\015\n\011\011c = 78+(c-golStart)*bit.lshift(1, sim.PMAPBITS)\015\n\011end\015\n\011if createOverride[c] then\015\n\011\011rx,ry,c = createOverride[c](rx,ry,c)\015\n\011end\015\n\011sim.createParts(x,y,rx,ry,c,brush,user.replacemode)\015\nend\015\nlocal function createLineAny(x1,y1,x2,y2,rx,ry,c,brush,user)\015\n\011if noShape[c] then return end\015\n\011if jacobsmod and c == tpt.element(\"ball\") and not user.shift then return end\015\n\011if c>=wallStart then\015\n\011\011if c<= wallEnd then\015\n\011\011\011if c == 284 then rx,ry = 0,0 end\015\n\011\011\011sim.createWallLine(x1,y1,x2,y2,rx,ry,c-wallStart,brush)\015\n\011\011elseif c<=toolEnd then\015\n\011\011\011if c>=toolStart then local str=1.0 if user.drawtype==4 then if user.shift then str=10.0 elseif user.alt then str=0.1 end end sim.toolLine(x1,y1,x2,y2,rx,ry,c-toolStart,brush,str) end\015\n\011\011elseif c<= decoEnd then\015\n\011\011\011sim.decoLine(x1,y1,x2,y2,rx,ry,user.dcolour[2],user.dcolour[3],user.dcolour[4],user.dcolour[1],c-decoStart,brush)\015\n\011\011end\015\n\011\011return\015\n\011elseif c>=golStart then\015\n\011\011c = 78+(c-golStart)*bit.lshift(1, sim.PMAPBITS)\015\n\011end\015\n\011if createOverride[c] then\015\n\011\011rx,ry,c = createOverride[c](rx,ry,c)\015\n\011end\015\n\011sim.createLine(x1,y1,x2,y2,rx,ry,c,brush,user.replacemode)\015\nend\015\nlocal function createBoxAny(x1,y1,x2,y2,c,user)\015\n\011if noShape[c] then return end\015\n\011if c>=wallStart then\015\n\011\011if c<= wallEnd then\015\n\011\011\011sim.createWallBox(x1,y1,x2,y2,c-wallStart)\015\n\011\011elseif c<=toolEnd then\015\n\011\011\011if c>=toolStart then sim.toolBox(x1,y1,x2,y2,c-toolStart) end\015\n\011\011elseif c<= decoEnd then\015\n\011\011\011sim.decoBox(x1,y1,x2,y2,user.dcolour[2],user.dcolour[3],user.dcolour[4],user.dcolour[1],c-decoStart)\015\n\011\011end\015\n\011\011return\015\n\011elseif c>=golStart then\015\n\011\011c = 78+(c-golStart)*bit.lshift(1, sim.PMAPBITS)\015\n\011end\015\n\011if createOverride[c] then\015\n\011\011_,_,c = createOverride[c](user.brushx,user.brushy,c)\015\n\011end\015\n\011sim.createBox(x1,y1,x2,y2,c,user and user.replacemode)\015\nend\015\nlocal function floodAny(x,y,c,cm,bm,user)\015\n\011if noFlood[c] then return end\015\n\011if c>=wallStart then\015\n\011\011if c<= wallEnd then\015\n\011\011\011sim.floodWalls(x,y,c-wallStart,bm)\015\n\011\011end\015\n\011\011--other tools shouldn't flood\015\n\011\011return\015\n\011elseif c>=golStart then --GoL adjust\015\n\011\011c = 78+(c-golStart)*bit.lshift(1, sim.PMAPBITS)\015\n\011end\015\n\011if createOverride[c] then\015\n\011\011_,_,c = createOverride[c](user.brushx,user.brushy,c)\015\n\011end\015\n\011sim.floodParts(x,y,c,cm,user.replacemode)\015\nend\015\nlocal function lineSnapCoords(x1,y1,x2,y2)\015\n\011local nx,ny\015\n\011local snapAngle = math.floor(math.atan2(y2-y1, x2-x1)/(math.pi*0.25)+0.5)*math.pi*0.25;\015\n\011local lineMag = math.sqrt(math.pow(x2-x1,2)+math.pow(y2-y1,2));\015\n\011nx = math.floor(lineMag*math.cos(snapAngle)+x1+0.5);\015\n\011ny = math.floor(lineMag*math.sin(snapAngle)+y1+0.5);\015\n\011return nx,ny\015\nend\015\n\015\nlocal function rectSnapCoords(x1,y1,x2,y2)\015\n\011local nx,ny\015\n\011local snapAngle = math.floor((math.atan2(y2-y1, x2-x1)+math.pi*0.25)/(math.pi*0.5)+0.5)*math.pi*0.5 - math.pi*0.25;\015\n\011local lineMag = math.sqrt(math.pow(x2-x1,2)+math.pow(y2-y1,2));\015\n\011nx = math.floor(lineMag*math.cos(snapAngle)+x1+0.5);\015\n\011ny = math.floor(lineMag*math.sin(snapAngle)+y1+0.5);\015\n\011return nx,ny\015\nend\015\nlocal function wallSnapCoords(x, y)\015\n\011return math.floor(x / 4) * 4, math.floor(y / 4) * 4\015\nend\015\nlocal renModes = {[0xff00f270]=1,[-16715152]=1,[0x0400f381]=2,[0xf382]=4,[0xf388]=8,[0xf384]=16,[0xfff380]=32,[1]=0xff00f270,[2]=0x0400f381,[4]=0xf382,[8]=0xf388,[16]=0xf384,[32]=0xfff380}\015\nlocal function getViewModes()\015\n\011local t={0,0,0}\015\n\011for k,v in pairs(ren.displayModes()) do\015\n\011\011t[1] = t[1]+v\015\n\011end\015\n\011for k,v in pairs(ren.renderModes()) do\015\n\011\011t[2] = t[2]+(renModes[v] or 0)\015\n\011end\015\n\011t[3] = ren.colorMode()\015\n\011return t\015\nend\015\n\015\n--clicky click\015\nlocal function playerMouseClick(id,btn,ev)\015\n\011local user = con.members[id]\015\n\011local createE, checkBut\015\n\015\n\011--_print(tostring(btn)..tostring(ev))\015\n\011if ev==0 then return end\015\n\011-- Mouse up event, TPT will \"draw\" whatever element was last clicked, even if we are releasing a different button\015\n\011-- This covers the case where we start drawing a line with rmb, switch to lmb, but then release rmb. The lmb element is drawn\015\n\011if ev == 2 then\015\n\011\011if user.lbtn then\015\n\011\011\011createE,checkBut=user.selectedl,user.lbtn\015\n\011\011elseif user.abtn then\015\n\011\011\011createE,checkBut=user.selecteda,user.abtn\015\n\011\011elseif user.rbtn then\015\n\011\011\011createE,checkBut=user.selectedr,user.rbtn\015\n\011\011else\015\n\011\011\011return\015\n\011\011end\015\n\011else\015\n\011\011if btn==1 then\015\n\011\011\011user.rbtn,user.abtn = false,false\015\n\011\011\011createE,checkBut=user.selectedl,user.lbtn\015\n\011\011elseif btn==2 then\015\n\011\011\011user.rbtn,user.lbtn = false,false\015\n\011\011\011createE,checkBut=user.selecteda,user.abtn\015\n\011\011elseif btn==3 then\015\n\011\011\011user.lbtn,user.abtn = false,false\015\n\011\011\011createE,checkBut=user.selectedr,user.rbtn\015\n\011\011else\015\n\011\011\011return\015\n\011\011end\015\n\011end\015\n\015\n\011--if user.mousex>=sim.XRES or user.mousey>=sim.YRES then user.drawtype=false return end\015\n\015\n\011if ev==1 then\015\n\011\011if user.mousex >= 0 and user.mousey >= 0 and user.mousex < sim.XRES and user.mousey < sim.YRES then\015\n\011\011\011user.pmx,user.pmy = user.mousex,user.mousey\015\n\011\011\011--left box\015\n\011\011\011if user.ctrl and not user.shift then user.drawtype = 2 return end\015\n\011\011\011--left line\015\n\011\011\011if user.shift and not user.ctrl then user.drawtype = 1 return end\015\n\011\011\011--floodfill\015\n\011\011\011if user.ctrl and user.shift then floodAny(user.mousex,user.mousey,createE,-1,-1,user) user.drawtype = 3 return end\015\n\011\011\011--an alt click\015\n\011\011\011if user.alt then return end\015\n\011\011\011user.drawtype=4 --normal hold\015\n\011\011\011createPartsAny(user.mousex,user.mousey,user.brushx,user.brushy,createE,user.brush,user)\015\n\011\011end\015\n\011elseif ev==2 and checkBut and user.drawtype then\015\n\011\011local releaseX, releaseY = user.mousex, user.mousey\015\n\011\011\015\n\011\011if user.drawtype==2 then\015\n\011\011\011if user.alt then user.mousex,user.mousey = rectSnapCoords(user.pmx,user.pmy,releaseX,releaseY) end\015\n\011\011\011createBoxAny(releaseX,releaseY,user.pmx,user.pmy,createE,user)\015\n\011\011elseif user.drawtype ~= 3 then\015\n\011\011\011if user.alt then user.mousex,user.mousey = lineSnapCoords(user.pmx,user.pmy,user.mousex,user.mousey) end\015\n\011\011\011createLineAny(releaseX,releaseY,user.pmx,user.pmy,user.brushx,user.brushy,createE,user.brush,user)\015\n\011\011end\015\n\011\011user.drawtype=false\015\n\011\011user.pmx,user.pmy = user.mousex,user.mousey\015\n\011end\015\nend\015\n--To draw continued lines\015\nlocal function playerMouseMove(id)\015\n\011local user = con.members[id]\015\n\011local createE, checkBut\015\n\011if user.lbtn then\015\n\011\011createE,checkBut=user.selectedl,user.lbtn\015\n\011elseif user.rbtn then\015\n\011\011createE,checkBut=user.selectedr,user.rbtn\015\n\011elseif user.abtn then\015\n\011\011createE,checkBut=user.selecteda,user.abtn\015\n\011else return end\015\n\011if user.drawtype~=4 then if user.drawtype==3 then floodAny(user.mousex,user.mousey,createE,-1,-1,user) end return end\015\n\011\015\n\011if user.mousex>=sim.XRES then user.mousex=sim.XRES-1 end\015\n\011if user.mousey>=sim.YRES then user.mousey=sim.YRES-1 end\015\n\011createLineAny(user.mousex,user.mousey,user.pmx,user.pmy,user.brushx,user.brushy,createE,user.brush,user)\015\n\011user.pmx,user.pmy = user.mousex,user.mousey\015\nend\015\nlocal function loadStamp(size,x,y,reset)\015\n\011con.socket:settimeout(10)\015\n\011local s = con.socket:receive(size)\015\n\011con.socket:settimeout(0)\015\n\011if s then\015\n\011\011local f = io.open(\".tmp.stm\",\"wb\")\015\n\011\011f:write(s)\015\n\011\011f:close()\015\n\011\011if reset then sim.clearSim() end\015\n\011\011if not sim.loadStamp(\".tmp.stm\",x,y) then\015\n\011\011\011infoText:reset(\"Error loading stamp\")\015\n\011\011end\015\n\011\011os.remove\".tmp.stm\"\015\n\011else\015\n\011\011infoText:reset(\"Error loading empty stamp\")\015\n\011end\015\nend\015\nlocal function saveStamp(x, y, w, h)\015\n\011local stampName = sim.saveStamp(x, y, w, h) or \"errorsavingstamp\"\015\n\011local fullName = \"stamps/\"..stampName..\".stm\"\015\n\011return stampName, fullName\015\nend\015\nlocal function deleteStamp(name)\015\n\011if sim.deleteStamp then\015\n\011\011sim.deleteStamp(name)\015\n\011else\015\n\011\011os.remove(\"stamps/\"..name..\".stm\")\015\n\011end\015\nend\015\n\015\nlocal dataCmds = {\015\n\011[16] = function()\015\n\011--room members\015\n\011\011con.members = {}\015\n\011\011local amount = cByte()\015\n\011\011local peeps = {}\015\n\011\011for i=1,amount do\015\n\011\011\011local id = cByte()\015\n\011\011\011con.members[id]={name=conGetNull(),mousex=0,mousey=0,brushx=4,brushy=4,brush=0,selectedl=1,selectedr=0,selecteda=296,replacemode=0,dcolour={0,0,0,0},lbtn=false,abtn=false,rbtn=false,ctrl=false,shift=false,alt=false}\015\n\011\011\011local name = con.members[id].name\015\n\011\011\011table.insert(peeps,name)\015\n\011\011end\015\n\011\011chatwindow:addline(\"Online: \"..table.concat(peeps,\" \"),255,255,50)\015\n\011end,\015\n\011[17]= function()\015\n\011\011local id = cByte()\015\n\011\011con.members[id] ={name=conGetNull(),mousex=0,mousey=0,brushx=4,brushy=4,brush=0,selectedl=1,selectedr=0,selecteda=296,replacemode=0,dcolour={0,0,0,0},lbtn=false,abtn=false,rbtn=false,ctrl=false,shift=false,alt=false}\015\n\011\011chatwindow:addline(con.members[id].name..\" has joined\",100,255,100)\015\n\011end,\015\n\011[18] = function()\015\n\011\011local id = cByte()\015\n\011\011chatwindow:addline(con.members[id].name..\" has left\",255,255,100)\015\n\011\011con.members[id]=nil\015\n\011end,\015\n\011[19] = function()\015\n\011\011chatwindow:addline(con.members[cByte()].name .. \": \" .. conGetNull())\015\n\011end,\015\n\011[20] = function()\015\n\011\011chatwindow:addline(\"* \"..con.members[cByte()].name .. \" \" .. conGetNull())\015\n\011end,\015\n\011[22] = function()\015\n\011\011chatwindow:addline(\"[SERVER] \"..conGetNull(), cByte(), cByte(), cByte())\015\n\011end,\015\n\011--Mouse Position\015\n\011[32] = function()\015\n\011\011local id = cByte()\015\n\011\011local b1,b2,b3=cByte(),cByte(),cByte()\015\n\011\011con.members[id].mousex,con.members[id].mousey=((b1*16)+math.floor(b2/16)),((b2%16)*256)+b3\015\n\011\011playerMouseMove(id)\015\n\011end,\015\n\011--Mouse Click\015\n\011[33] = function()\015\n\011\011local id = cByte()\015\n\011\011local d=cByte()\015\n\011\011local btn,ev=math.floor(d/16),d%16\015\n\011\011-- Fake mouseup due to either blur or zoom window\015\n\011\011if btn == 0 then\015\n\011\011\011local user = con.members[id]\015\n\011\011\011user.lbtn, user.rbtn, user.abtn, user.drawtype = nil, nil, nil, nil\015\n\011\011\011return\015\n\011\011end\015\n\011\011playerMouseClick(id,btn,ev)\015\n\011\011if ev==0 then return end\015\n\011\011if ev==2 then ev = nil end\015\n\011\011if btn==1 then\015\n\011\011\011con.members[id].lbtn=ev\015\n\011\011elseif btn==2 then\015\n\011\011\011con.members[id].abtn=ev\015\n\011\011elseif btn==3 then\015\n\011\011\011con.members[id].rbtn=ev\015\n\011\011end\015\n\011end,\015\n\011--Brush size\015\n\011[34] = function()\015\n\011\011local id = cByte()\015\n\011\011con.members[id].brushx,con.members[id].brushy=cByte(),cByte()\015\n\011end,\015\n\011--Brush Shape change, no args\015\n\011[35] = function()\015\n\011\011local id = cByte()\015\n\011\011con.members[id].brush=(con.members[id].brush+1)%3\015\n\011end,\015\n\011--Modifier (mod and state)\015\n\011[36] = function()\015\n\011\011local id = cByte()\015\n\011\011local d=cByte()\015\n\011\011local mod,state=math.floor(d/16),d%16~=0\015\n\011\011if mod==0 then\015\n\011\011\011con.members[id].ctrl=state\015\n\011\011elseif mod==1 then\015\n\011\011\011con.members[id].shift=state\015\n\011\011elseif mod==2 then\015\n\011\011\011con.members[id].alt=state\015\n\011\011end\015\n\011end,\015\n\011--selected elements (2 bits button, 14-element)\015\n\011[37] = function()\015\n\011\011local id = cByte()\015\n\011\011local b1,b2=cByte(),cByte()\015\n\011\011local btn,el=math.floor(b1/64),(b1%64)*256+b2\015\n\011\011if btn==0 then\015\n\011\011\011con.members[id].selectedl=el\015\n\011\011elseif btn==1 then\015\n\011\011\011con.members[id].selecteda=el\015\n\011\011elseif btn==2 then\015\n\011\011\011con.members[id].selectedr=el\015\n\011\011elseif btn==3 then\015\n\011\011\011--sync replace mode element between all players since apparently you have to set tpt.selectedreplace to use replace mode ...\015\n\011\011\011tpt.selectedreplace = elem.property(el, \"Identifier\")\015\n\011\011end\015\n\011end,\015\n\011--replace mode / specific delete\015\n\011[38] = function()\015\n\011\011local id = cByte()\015\n\011\011local mod = cByte()\015\n\011\011con.members[id].replacemode = mod\015\n\011end,\015\n\011--cmode defaults (1 byte mode)\015\n\011[48] = function()\015\n\011\011local id = cByte()\015\n\011\011tpt.display_mode(cByte())\015\n\011\011cmodeText:reset(con.members[id].name..\" set:\")\015\n\011end,\015\n\011--pause set (1 byte state)\015\n\011[49] = function()\015\n\011\011local id = cByte()\015\n\011\011local p,str = cByte(),\"Pause\"\015\n\011\011tpt.set_pause(p)\015\n\011\011if p==0 then str=\"Unpause\" end\015\n\011\011infoText:reset(str..\" from \"..con.members[id].name)\015\n\011end,\015\n\011--step frame, no args\015\n\011[50] = function()\015\n\011\011local id = cByte()\015\n\011\011tpt.set_pause(0)\015\n\011\011L.pauseNextFrame=true\015\n\011end,\015\n\011--deco mode, (1 byte state)\015\n\011[51] = function()\015\n\011\011local id = cByte()\015\n\011\011tpt.decorations_enable(cByte())\015\n\011\011cmodeText:reset(con.members[id].name..\" set:\")\015\n\011end,\015\n\011--[[HUD mode, (1 byte state), deprecated\015\n\011[52] = function()\015\n\011\011local id = cByte()\015\n\011\011local hstate = cByte()\015\n\011\011tpt.hud(hstate)\015\n\011end,\015\n\011--]]\015\n\011--amb heat mode, (1 byte state)\015\n\011[53] = function()\015\n\011\011local id = cByte()\015\n\011\011tpt.ambient_heat(cByte())\015\n\011end,\015\n\011--newt_grav mode, (1 byte state)\015\n\011[54] = function()\015\n\011\011local id = cByte()\015\n\011\011tpt.newtonian_gravity(cByte())\015\n\011end,\015\n\015\n\011--[[\015\n\011--debug mode (1 byte state?) can't implement\015\n\011[55] = function()\015\n\011\011local id = cByte()\015\n\011\011--local dstate = cByte()\015\n\011\011tpt.setdebug()\015\n\011end,\015\n\011--]]\015\n\011--legacy heat mode, (1 byte state)\015\n\011[56] = function()\015\n\011\011local id = cByte()\015\n\011\011tpt.heat(cByte())\015\n\011end,\015\n\011--water equal, (1 byte state)\015\n\011[57] = function()\015\n\011\011local id = cByte()\015\n\011\011sim.waterEqualisation(cByte())\015\n\011end,\015\n\015\n\011--grav mode, (1 byte state)\015\n\011[58] = function()\015\n\011\011local id = cByte()\015\n\011\011local mode = cByte()\015\n\011\011sim.gravityMode(mode)\015\n\011\011cmodeText:reset(con.members[id].name..\" set: Gravity: \"..gravList[mode])\015\n\011end,\015\n\011--air mode, (1 byte state)\015\n\011[59] = function()\015\n\011\011local id = cByte()\015\n\011\011local mode=cByte()\015\n\011\011sim.airMode(mode)\015\n\011\011cmodeText:reset(con.members[id].name..\" set: Air: \"..airList[mode])\015\n\011end,\015\n\015\n\011--clear sparks (no args)\015\n\011[60] = function()\015\n\011\011local id = cByte()\015\n\011\011tpt.reset_spark()\015\n\011end,\015\n\011--clear pressure/vel (no args)\015\n\011[61] = function()\015\n\011\011local id = cByte()\015\n\011\011tpt.reset_velocity()\015\n\011\011tpt.set_pressure()\015\n\011end,\015\n\011--invert pressure (no args)\015\n\011[62] = function()\015\n\011\011local id = cByte()\015\n\011\011for x=0,152 do\015\n\011\011\011for y=0,95 do\015\n\011\011\011\011sim.pressure(x,y,-sim.pressure(x,y))\015\n\011\011\011end\015\n\011\011end\015\n\011end,\015\n\011--Clearsim button (no args)\015\n\011[63] = function()\015\n\011\011local id = cByte()\015\n\011\011sim.clearSim()\015\n\011\011L.lastSave=nil\015\n\011\011infoText:reset(con.members[id].name..\" cleared the screen\")\015\n\011end,\015\n\011--Full graphics view mode (for manual changes in display menu) (3 bytes)\015\n\011[64] = function()\015\n\011\011local id = cByte()\015\n\011\011local disM,renM,colM = cByte(),cByte(),cByte()\015\n\011\011ren.displayModes({disM})\015\n\011\011local t,i={},1\015\n\011\011while i<=32 do\015\n\011\011\011if bit.band(renM,i)>0 then table.insert(t,renModes[i]) end\015\n\011\011\011i=i*2\015\n\011\011end\015\n\011\011ren.renderModes(t)\015\n\011\011ren.colorMode(colM)\015\n\011end,\015\n\011--Selected deco colour (4 bytes)\015\n\011[65] = function()\015\n\011\011local id = cByte()\015\n\011\011con.members[id].dcolour = {cByte(),cByte(),cByte(),cByte()}\015\n\011end,\015\n\011--Recieve a stamp, with location (6 bytes location(3),size(3))\015\n\011[66] = function()\015\n\011\011local id = cByte()\015\n\011\011local b1,b2,b3=cByte(),cByte(),cByte()\015\n\011\011local x,y =((b1*16)+math.floor(b2/16)),((b2%16)*256)+b3\015\n\011\011local d = cByte()*65536+cByte()*256+cByte()\015\n\011\011loadStamp(d,x,y,false)\015\n\011\011infoText:reset(\"Stamp from \"..con.members[id].name)\015\n\011end,\015\n\011--Clear an area, helper for cut (6 bytes, start(3), end(3))\015\n\011[67] = function()\015\n\011\011local id = cByte()\015\n\011\011local b1,b2,b3,b4,b5,b6=cByte(),cByte(),cByte(),cByte(),cByte(),cByte()\015\n\011\011local x1,y1 =((b1*16)+math.floor(b2/16)),((b2%16)*256)+b3\015\n\011\011local x2,y2 =((b4*16)+math.floor(b5/16)),((b5%16)*256)+b6\015\n\011\011sim.clearRect(x1,y1,x2-x1+1,y2-y1+1)\015\n\011end,\015\n\011--Edge mode (1 byte state)\015\n\011[68] = function()\015\n\011\011local id = cByte()\015\n\011\011sim.edgeMode(cByte())\015\n\011end,\015\n\011--Load a save ID (3 bytes ID)\015\n\011[69] = function()\015\n\011\011local id = cByte()\015\n\011\011local saveID = cByte()*65536+cByte()*256+cByte()\015\n\011\011L.lastSave=saveID\015\n\011\011sim.loadSave(saveID,1)\015\n\011end,\015\n\011--Reload sim(from a stamp right now, no args)\015\n\011[70] = function()\015\n\011\011local id = cByte()\015\n\011\011sim.reloadSave()\015\n\011\011infoText:reset(con.members[id].name..\" reloaded the save\")\015\n\011end,\015\n\011--A request to sync a player, from server, send screen, and various settings\015\n\011[128] = function()\015\n\011\011local id = cByte()\015\n\011\011conSend(130,string.char(id,49,tpt.set_pause()))\015\n\011\011local stampName,fullName = saveStamp(0,0,sim.XRES-1,sim.YRES-1)\015\n\011\011local f = assert(io.open(fullName,\"rb\"))\015\n\011\011local s = f:read\"*a\"\015\n\011\011f:close()\015\n\011\011deleteStamp(stampName)\015\n\011\011local d = #s\015\n\011\011conSend(128,string.char(id,math.floor(d/65536),math.floor(d/256)%256,d%256)..s)\015\n\011\011conSend(130,string.char(id,53,tpt.ambient_heat()))\015\n\011\011conSend(130,string.char(id,54,tpt.newtonian_gravity()))\015\n\011\011conSend(130,string.char(id,56,tpt.heat()))\015\n\011\011conSend(130,string.char(id,57,sim.waterEqualisation()))\015\n\011\011conSend(130,string.char(id,58,sim.gravityMode()))\015\n\011\011conSend(130,string.char(id,59,sim.airMode()))\015\n\011\011conSend(130,string.char(id,68,sim.edgeMode()))\015\n\011\011conSend(64,string.char(unpack(getViewModes())))\015\n\011\011conSend(34,string.char(tpt.brushx,tpt.brushy))\015\n\011end,\015\n\011--Recieve sync stamp\015\n\011[129] = function()\015\n\011\011local d = cByte()*65536+cByte()*256+cByte()\015\n\011\011loadStamp(d,0,0,true)\015\n\011end,\015\n}\015\n\015\nlocal function connectThink()\015\n\011if not con.connected then return end\015\n\011if not con.socket then disconnected() return end\015\n\011--read all messages\015\n\011while 1 do\015\n\011\011local s,r = con.socket:receive(1)\015\n\011\011if s then\015\n\011\011\011local cmd = string.byte(s)\015\n\011\011\011--_print(\"GOT \"..tostring(cmd))\015\n\011\011\011if dataCmds[cmd] then dataCmds[cmd]() else _print(\"TPTMP: Unknown protocol \"..tostring(cmd),255,20,20) end\015\n\011\011else\015\n\011\011\011if r ~= \"timeout\" then disconnected() end\015\n\011\011\011break\015\n\011\011end\015\n\011end\015\n\015\n\011--ping every minute\015\n\011if os.time()>con.pingTime then conSend(2) con.pingTime=os.time()+60 end\015\nend\015\n--Track if we have STKM2 out, for WASD key changes\015\nelements.property(128,\"Update\",function() L.stick2=true end)\015\n\015\nlocal function drawStuff()\015\n\011if con.members then\015\n\011\011for i,user in pairs(con.members) do\015\n\011\011\011local x,y = user.mousex,user.mousey\015\n\011\011\011local brx,bry=user.brushx,user.brushy\015\n\011\011\011local brush,drawBrush=user.brush,true\015\n\011\011\011gfx.drawText(x,y,(\"%s %dx%d\"):format(user.name,brx,bry),0,255,0,192)\015\n\015\n\011\011\011-- Draw player cursors\015\n\011\011\011if user.drawtype==1 then\015\n\011\011\011\011if user.alt then x,y = lineSnapCoords(user.pmx,user.pmy,x,y) end\015\n\011\011\011\011gfx.drawLine(user.pmx,user.pmy,x,y,0,255,0,128)\015\n\011\011\011elseif user.drawtype==2 then\015\n\011\011\011\011if user.alt then x,y = rectSnapCoords(user.pmx,user.pmy,x,y) end\015\n\011\011\011\011local tpmx,tpmy = user.pmx,user.pmy\015\n\011\011\011\011if tpmx>x then tpmx,x=x,tpmx end\015\n\011\011\011\011if tpmy>y then tpmy,y=y,tpmy end\015\n\011\011\011\011gfx.drawRect(tpmx,tpmy,x-tpmx+1,y-tpmy+1,0,255,0,128)\015\n\011\011\011\011drawBrush=false\015\n\011\011\011elseif user.drawtype==3 or (user.shift and user.ctrl) then\015\n\011\011\011\011gfx.drawLine(x,y,x+5,y,0,255,0,128)\015\n\011\011\011\011gfx.drawLine(x,y,x-5,y,0,255,0,128)\015\n\011\011\011\011gfx.drawLine(x,y,x,y+5,0,255,0,128)\015\n\011\011\011\011gfx.drawLine(x,y,x,y-5,0,255,0,128)\015\n\011\011\011\011drawBrush=false\015\n\011\011\011end\015\n\015\n\011\011\011if drawBrush then\015\n\011\011\011\011if user.selectedl >= wallStart and user.selectedl <= wallEnd then\015\n\011\011\011\011\011local blockX, blockY = wallSnapCoords(x, y)\015\n\011\011\011\011\011local blockRadX, blockRadY = wallSnapCoords(brx, bry)\015\n\011\011\011\011\011\015\n\011\011\011\011\011local x1, y1 = blockX - blockRadX, blockY - blockRadY\015\n\011\011\011\011\011local x2, y2 = blockX + blockRadX + 3, blockY + blockRadY + 3\015\n\011\011\011\011\011gfx.drawRect(x1, y1, x2 - x1, y2 - y1)\015\n\011\011\011\011elseif brush==0 then\015\n\011\011\011\011\011gfx.drawCircle(x,y,brx,bry,0,255,0,128)\015\n\011\011\011\011elseif brush==1 then\015\n\011\011\011\011\011gfx.drawRect(x-brx,y-bry,brx*2+1,bry*2+1,0,255,0,128)\015\n\011\011\011\011elseif brush==2 then\015\n\011\011\011\011\011gfx.drawLine(x-brx,y+bry,x,y-bry,0,255,0,128)\015\n\011\011\011\011\011gfx.drawLine(x-brx,y+bry,x+brx,y+bry,0,255,0,128)\015\n\011\011\011\011\011gfx.drawLine(x,y-bry,x+brx,y+bry,0,255,0,128)\015\n\011\011\011\011end\015\n\011\011\011end\015\n\011\011end\015\n\011end\015\n\011for k,v in pairs(fadeText) do\015\n\011\011if v.ticks > 0 then\015\n\011\011\011local a = math.floor(255*(v.ticks/v.max))\015\n\011\011\011gfx.drawText(v.x,v.y,v.text,v.r,v.g,v.b,a)\015\n\011\011\011v.ticks = v.ticks-1\015\n\011\011else if not v.keep then table.remove(fadeText,k) end\015\n\011\011end\015\n\011end\015\nend\015\n\015\nlocal function sendStuff()\015\n\011if not con.connected then return end\015\n\011if tpt.brushx > 255 then tpt.brushx = 255 end\015\n\011if tpt.brushy > 255 then tpt.brushy = 255 end\015\n\011local nbx,nby = tpt.brushx,tpt.brushy\015\n\011if L.brushx~=nbx or L.brushy~=nby then\015\n\011\011L.brushx,L.brushy = nbx,nby\015\n\011\011conSend(34,string.char(L.brushx,L.brushy))\015\n\011end\015\n\011--check selected elements\015\n\011local nsell,nsela,nselr,nselrep = elements[tpt.selectedl] or eleNameTable[tpt.selectedl],elements[tpt.selecteda] or eleNameTable[tpt.selecteda],elements[tpt.selectedr] or eleNameTable[tpt.selectedr],elements[tpt.selectedreplace] or eleNameTable[tpt.selectedreplace]\015\n\011if L.sell~=nsell then\015\n\011\011L.sell=nsell\015\n\011\011if nsell == nil then\015\n\011\011\011_print(\"Unsupported wall/tool \"..tpt.selectedl)\015\n\011\011else\015\n\011\011\011conSend(37,string.char(math.floor(L.sell/256),L.sell%256))\015\n\011\011end\015\n\011elseif L.sela~=nsela then\015\n\011\011L.sela=nsela\015\n\011\011if nsela == nil then\015\n\011\011\011_print(\"Unsupported wall/tool \"..tpt.selecteda)\015\n\011\011else\015\n\011\011\011conSend(37,string.char(math.floor(64 + L.sela/256),L.sela%256))\015\n\011\011end\015\n\011elseif L.selr~=nselr then\015\n\011\011L.selr=nselr\015\n\011\011if nselr == nil then\015\n\011\011\011_print(\"Unsupported wall/tool \"..tpt.selectedr)\015\n\011\011else\015\n\011\011\011conSend(37,string.char(math.floor(128 + L.selr/256),L.selr%256))\015\n\011\011end\015\n\011elseif L.selrep~=nselrep then\015\n\011\011L.selrep=nselrep\015\n\011\011if nselrep == nil then\015\n\011\011\011_print(\"Unsupported wall/tool \"..tpt.selectedreplace)\015\n\011\011else\015\n\011\011\011conSend(37,string.char(math.floor(192 + L.selrep/256),L.selrep%256))\015\n\011\011end\015\n\011end\015\n\011local ncol = sim.decoColour()\015\n\011if L.dcolour~=ncol then\015\n\011\011L.dcolour=ncol\015\n\011\011conSend(65,string.char(math.floor(ncol/16777216),math.floor(ncol/65536)%256,math.floor(ncol/256)%256,ncol%256))\015\n\011end\015\n\015\n\011--Tell others to open this save ID, or send screen if opened local browser\015\n\011if L.browseMode==1 then\015\n\011\011--loaded online save\015\n\011\011local id=sim.getSaveID()\015\n\011\011if L.lastSave~=id then\015\n\011\011\011L.lastSave=id\015\n\011\011\011conSend(69,string.char(math.floor(id/65536),math.floor(id/256)%256,id%256))\015\n\011\011end\015\n\011\011L.browseMode=nil\015\n\011elseif L.browseMode==2 then\015\n\011\011--loaded local save (should probably clear sim first instead?)\015\n\011\011L.sendScreen=true\015\n\011\011L.browseMode=nil\015\n\011end\015\n\015\n\011--Send screen (or an area for known size) for stamps\015\n\011if jacobsmod and L.sendScreen == 2 then\015\n\011\011L.sendScreen = true\015\n\011elseif L.sendScreen then\015\n\011\011local x,y,w,h = 0,0,sim.XRES-1,sim.YRES-1\015\n\011\011if L.smoved then\015\n\011\011\011local stm\015\n\011\011\011if L.copying then stm=L.lastCopy else stm=L.lastStamp end\015\n\011\011\011if L.rotate then stm.w,stm.h=stm.h,stm.w end\015\n\011\011\011x,y,w,h = math.floor((L.mousex-stm.w/2)/4)*4,math.floor((L.mousey-stm.h/2)/4)*4,stm.w,stm.h\015\n\011\011\011L.smoved=false\015\n\011\011\011L.copying=false\015\n\011\011end\015\n\011\011L.sendScreen=false\015\n\011\011local stampName,fullName = saveStamp(x,y,w,h)\015\n\011\011local f = assert(io.open(fullName,\"rb\"))\015\n\011\011local s = f:read\"*a\"\015\n\011\011f:close()\015\n\011\011deleteStamp(stampName)\015\n\011\011local d = #s\015\n\011\011local b1,b2,b3 = math.floor(x/16),((x%16)*16)+math.floor(y/256),(y%256)\015\n\011\011conSend(67,string.char(math.floor(x/16),((x%16)*16)+math.floor(y/256),(y%256),math.floor((x+w)/16),(((x+w)%16)*16)+math.floor((y+h)/256),((y+h)%256)))\015\n\011\011conSend(66,string.char(b1,b2,b3,math.floor(d/65536),math.floor(d/256)%256,d%256)..s)\015\n\011\011conSend(49,string.char(tpt.set_pause()))\015\n\011end\015\n\015\n\011--Check if custom modes were changed\015\n\011if jacobsmod and L.checkRen == 2 then\015\n\011\011L.checkRen = true\015\n\011elseif L.checkRen then\015\n\011\011L.checkRen=false\015\n\011\011local t,send=getViewModes(),false\015\n\011\011for k,v in pairs(t) do\015\n\011\011\011if v~=L.pModes[k] then\015\n\011\011\011\011send=true break\015\n\011\011\011end\015\n\011\011end\015\n\011\011if send then conSend(64,string.char(t[1],t[2],t[3])) end\015\n\011end\015\n\015\n\011--Send option menu settings\015\n\011if L.checkOpt then\015\n\011\011L.checkOpt=false\015\n\011\011conSend(49,string.char(tpt.set_pause()))\015\n\011\011conSend(56,string.char(tpt.heat()))\015\n\011\011conSend(53,string.char(tpt.ambient_heat()))\015\n\011\011conSend(54,string.char(tpt.newtonian_gravity()))\015\n\011\011conSend(57,string.char(sim.waterEqualisation()))\015\n\011\011conSend(58,string.char(sim.gravityMode()))\015\n\011\011conSend(59,string.char(sim.airMode()))\015\n\011\011conSend(68,string.char(sim.edgeMode()))\015\n\011end\015\n\015\nend\015\nlocal function updatePlayers()\015\n\011if con.members then\015\n\011\011for k,v in pairs(con.members) do\015\n\011\011\011playerMouseMove(k)\015\n\011\011end\015\n\011end\015\n\011--Keep last frame of stick2\015\n\011L.lastStick2=L.stick2\015\n\011L.stick2=false\015\nend\015\n\015\nlocal pressedKeys\015\nlocal function step()\015\n\011if jacobsmod_old_menu_check then showbutton:onmove(0, getypos()-showbutton.y) end\015\n\011if not L.chatHidden then chatwindow:draw() else showbutton:draw() end\015\n\011if hooks_enabled then\015\n\011\011drawStuff()\015\n\011\011sendStuff()\015\n\011\011if L.pauseNextFrame then L.pauseNextFrame=false tpt.set_pause(1) end\015\n\011\011connectThink()\015\n\011\011updatePlayers()\015\n\011end\015\nend\015\n\015\n--some button locations that emulate tpt, return false will disable button\015\nlocal tpt_buttons = {\015\n\011[\"open\"] = {x1=1, y1=408, x2=17, y2=422, f=function() if not L.ctrl then L.browseMode=1 else L.browseMode=2 end L.lastSave=sim.getSaveID() end},\015\n\011[\"rload\"] = {x1=19, y1=408, x2=35, y2=422, f=function()\015\n\011\011if L.lastSave then\015\n\011\011\011if L.ctrl then\015\n\011\011\011\011infoText:reset(\"If you re-opened the save, please type /sync\")\015\n\011\011\011else\015\n\011\011\011\011conSend(70)\015\n\011\011\011\011infoText:reset(\"Sent sync\")\015\n\011\011\011end\015\n\011\011else\015\n\011\011\011--[[infoText:reset(\"Reloading local saves is not synced currently. Type /sync\")]]\015\n\011\011\011L.checkOpt = true\015\n\011\011\011L.sendScreen = true\015\n\011\011end\015\n\011end},\015\n\011[\"clear\"] = {x1=470, y1=408, x2=486, y2=422, f=function() conSend(63) L.lastSave=nil end},\015\n\011[\"opts\"] = {x1=581, y1=408, x2=595, y2=422, f=function() L.checkOpt=true end},\015\n\011[\"disp\"] = {x1=597, y1=408, x2=611, y2=422, f=function() L.checkRen=true L.pModes=getViewModes() end},\015\n\011[\"pause\"] = {x1=gfx.WIDTH-16, y1=408, x2=gfx.WIDTH-2, y2=422, f=function() conSend(49,tpt.set_pause()==0 and \"\\1\" or \"\\0\") end},\015\n\011[\"deco\"] = {x1=gfx.WIDTH-16, y1=33, x2=gfx.WIDTH-2, y2=47, f=function() if jacobsmod and (L.tabs or L.ctrl) then return end conSend(51,tpt.decorations_enable()==0 and \"\\1\" or \"\\0\") end},\015\n\011[\"newt\"] = {x1=gfx.WIDTH-16, y1=49, x2=gfx.WIDTH-2, y2=63, f=function() if jacobsmod and (L.tabs or L.ctrl) then return end conSend(54,tpt.newtonian_gravity()==0 and \"\\1\" or \"\\0\") end},\015\n\011[\"ambh\"] = {x1=gfx.WIDTH-16, y1=65, x2=gfx.WIDTH-2, y2=79, f=function() if jacobsmod and (L.tabs or L.ctrl) then return end conSend(53,tpt.ambient_heat()==0 and \"\\1\" or \"\\0\") end},\015\n}\015\nif jacobsmod then\015\n\011tpt_buttons[\"tab\"] = {x1=gfx.WIDTH-16, y1=1, x2=gfx.WIDTH-2, y2=15, f=function() L.tabs = not L.tabs end}\015\n\011tpt_buttons[\"tabs\"] = {x1=gfx.WIDTH-16, y1=17, x2=gfx.WIDTH-2, y2=147, f=function() if L.tabs or L.ctrl then L.sendScreen = true end end}\015\n\011tpt_buttons[\"opts\"] = {x1=465, y1=408, x2=479, y2=422, f=function() L.checkOpt=true end}\015\n\011tpt_buttons[\"clear\"] = {x1=481, y1=408, x2=497, y2=422, f=function() conSend(63) L.lastSave=nil end}\015\n\011tpt_buttons[\"disp\"] = {x1=595, y1=408, x2=611, y2=422,f=function() L.checkRen=2 L.pModes=getViewModes() end}\015\n\011tpt_buttons[\"open\"] = {x1=1, y1=408, x2=17, y2=422, f=function() if not L.ctrl then L.browseMode=1 else L.browseMode=2 end L.lastSave=sim.getSaveID() end}\015\nend\015\n\015\nlocal function inZoomWindow(x, y)\015\n\011if not L.isDrawing and (x < 0 or x >= sim.XRES or y < 0 or y >= sim.YRES) then\015\n\011\011return false\015\n\011end\015\n\011local snappedX, snappedY = x, y\015\n\011-- When the mouse is outside the window, TPT will snap coords to simulation area then check for zoom window\015\n\011if snappedX < 0 then snappedX = 0 elseif snappedX >= sim.XRES then snappedX = sim.XRES end\015\n\011if snappedY < 0 then snappedY = 0 elseif snappedY >= sim.YRES then snappedY = sim.YRES end\015\n\011local zoomX, zoomY = sim.adjustCoords(snappedX, snappedY)\015\n\011return zoomX ~= x or zoomY ~= y\015\nend\015\n\015\nlocal function sendMouseUpdate(mouseX, mouseY)\015\n\011L.realMouseX, L.realMouseY = mouseX, mouseY\015\n\011if inZoomWindow(mouseX, mouseY) then\015\n\011\011mouseX, mouseY = sim.adjustCoords(mouseX, mouseY)\011\015\n\011else\015\n\011\011if mouseX < 0 then mouseX = 0 end\015\n\011\011if mouseY < 0 then mouseY = 0 end\015\n\011\011if mouseX > gfx.WIDTH then mouseX = gfx.WIDTH end\015\n\011\011if mouseY > gfx.HEIGHT then mouseY = gfx.HEIGHT end\015\n\011end\015\n\015\n\011if L.mousex ~= mouseX or L.mousey ~= mouseY then\015\n\011\011local b1, b2, b3 = math.floor(mouseX / 16), ((mouseX % 16) * 16) + math.floor(mouseY / 256), (mouseY % 256)\015\n\011\011conSend(32, string.char(b1, b2, b3))\015\n\011\011L.mousex, L.mousey = mouseX, mouseY\015\n\011end\015\nend\015\n\015\nlocal function mouseDown(mouseX, mouseY, button)\015\n\011if L.chatHidden then\015\n\011\011showbutton:mouseDown(mouseX, mouseY, button)\015\n\011\011if not hooks_enabled then\015\n\011\011\011return true\015\n\011\011end\015\n\011end\015\n\011if L.stamp and button == 1 then\015\n\011\011L.stampx, L.stampy = mouseX, mouseY\015\n\011\011return true\015\n\011end\015\n\011if L.stamp or L.placeStamp then\015\n\011\011return true\015\n\011end\015\n\011if L.skipClick then\015\n\011\011L.skipClick = false\015\n\011\011return true\015\n\011end\015\n\011if chatwindow:mouseDown(mouseX, mouseY, button) then\015\n\011\011return false\015\n\011end\015\n\015\n\011sendMouseUpdate(mouseX, mouseY)\015\n\011local obut, oevnt = L.mButt, L.mEvent\015\n\011if button ~= obut or 1 ~= oevnt then\015\n\011\011L.mButt, L.mEvent = button, 1\015\n\011\011if mouseX >= 0 and mouseY >= 0 and mouseX < sim.XRES and mouseY < sim.YRES then\015\n\011\011\011L.isDrawing = true\015\n\011\011end\015\n\011\011conSend(33, string.char(L.mButt * 16 + L.mEvent))\015\n\011end\015\n\011\015\n\011-- Click inside button first\015\n\011if button==1 then\015\n\011\011for k, v in pairs(tpt_buttons) do\015\n\011\011\011if mouseX >= v.x1 and mouseX <= v.x2 and mouseY >= v.y1 and mouseY <= v.y2 then\015\n\011\011\011\011v.downInside = true\015\n\011\011\011end\015\n\011\011end\015\n\011end\015\nend\015\n\015\nlocal function mouseUp(mouseX, mouseY, button, reason)\015\n\011if L.chatHidden then\015\n\011\011showbutton:mouseUp(mouseX, mouseY, button)\015\n\011\011if not hooks_enabled then\015\n\011\011\011return true\015\n\011\011end\015\n\011end\015\n\011if L.stamp then\015\n\011\011if L.skipClick then\015\n\011\011\011L.skipClick = false\015\n\011\011\011return true\015\n\011\011end\015\n\011\011--stamp has been saved, make our own copy\015\n\011\011if button==1 then\015\n\011\011\011--save stamp ourself for data, delete it\015\n\011\011\011local sx,sy = mouseX, mouseY\015\n\011\011\011if sx<L.stampx then L.stampx,sx=sx,L.stampx end\015\n\011\011\011if sy<L.stampy then L.stampy,sy=sy,L.stampy end\015\n\011\011\011--cheap cut hook to send a clear\015\n\011\011\011if L.copying==1 then\015\n\011\011\011\011--maybe this is ctrl+x? 67 is clear area\015\n\011\011\011\011conSend(67,string.char(math.floor(L.stampx/16),((L.stampx%16)*16)+math.floor(L.stampy/256),(L.stampy%256),math.floor(sx/16),((sx%16)*16)+math.floor(sy/256),(sy%256)))\015\n\011\011\011end\015\n\011\011\011local w,h = sx-L.stampx,sy-L.stampy\015\n\011\011\011local stampName,fullName = saveStamp(L.stampx,L.stampy,w,h)\015\n\011\011\011sx,sy,L.stampx,L.stampy = math.ceil((sx+1)/4)*4,math.ceil((sy+1)/4)*4,math.floor(L.stampx/4)*4,math.floor(L.stampy/4)*4\015\n\011\011\011w,h = sx-L.stampx, sy-L.stampy\015\n\011\011\011local f = assert(io.open(fullName,\"rb\"))\015\n\011\011\011if L.copying then L.lastCopy = {data=f:read\"*a\",w=w,h=h} else L.lastStamp = {data=f:read\"*a\",w=w,h=h} end\015\n\011\011\011f:close()\015\n\011\011\011deleteStamp(stampName)\015\n\011\011end\015\n\011\011L.stamp=false\015\n\011\011L.copying=false\015\n\011end\015\n\011if L.placeStamp and reason == 0 then\015\n\011\011if L.skipClick then\015\n\011\011\011L.skipClick=false\015\n\011\011\011return true\015\n\011\011end\015\n\011\011if button==1 then\015\n\011\011\011local stm\015\n\011\011\011if L.copying then stm=L.lastCopy else stm=L.lastStamp end\015\n\011\011\011if stm then\015\n\011\011\011\011if not stm.data then\015\n\011\011\011\011\011--unknown stamp, send full screen on next step, how can we read last created stamp, timestamps on files?\015\n\011\011\011\011\011L.sendScreen = (jacobsmod and 2 or true)\015\n\011\011\011\011else\015\n\011\011\011\011\011--send the stamp\015\n\011\011\011\011\011if L.smoved then\015\n\011\011\011\011\011\011--moved from arrows or rotate, send area next frame\015\n\011\011\011\011\011\011L.placeStamp=false\015\n\011\011\011\011\011\011L.sendScreen=true\015\n\011\011\011\011\011\011return true\015\n\011\011\011\011\011end\015\n\011\011\011\011\011local sx,sy = mouseX-math.floor(stm.w/2),mouseY-math.floor((stm.h)/2)\015\n\011\011\011\011\011if sx<0 then sx=0 end\015\n\011\011\011\011\011if sy<0 then sy=0 end\015\n\011\011\011\011\011if sx+stm.w>sim.XRES-1 then sx=sim.XRES-stm.w end\015\n\011\011\011\011\011if sy+stm.h>sim.YRES-1 then sy=sim.YRES-stm.h end\015\n\011\011\011\011\011local b1,b2,b3 = math.floor(sx/16),((sx%16)*16)+math.floor(sy/256),(sy%256)\015\n\011\011\011\011\011local d = #stm.data\015\n\011\011\011\011\011conSend(66,string.char(b1,b2,b3,math.floor(d/65536),math.floor(d/256)%256,d%256)..stm.data)\015\n\011\011\011\011end\015\n\011\011\011end\015\n\011\011end\015\n\011\011L.placeStamp=false\015\n\011\011L.copying=false\015\n\011end\015\n\011\015\n\011if L.skipClick then\015\n\011\011L.skipClick = false\015\n\011\011return true\015\n\011end\015\n\011if chatwindow:mouseUp(mouseX, mouseY, button, reason) then\015\n\011\011return false\015\n\011end\015\n\015\n\011-- Ignore fake mouseups due to blur (don't send 0, 0 coordinate)\015\n\011-- Also ignore fake mouseups due to going into / outside of zoom window\015\n\011-- In both cases, tell other clients we're no longer holding the mouse, without causing it to draw the line\015\n\011if reason == 1 or reason == 2 then\015\n\011\011L.mButt, L.mEvent = button, 2\015\n\011\011L.isDrawing = false\015\n\011\011conSend(33, string.char(0 * 16 + L.mEvent))\015\n\011\011return\015\n\011end\015\n\015\n\011sendMouseUpdate(mouseX, mouseY)\015\n\011local obut, oevnt = L.mButt, L.mEvent\015\n\011if button ~= obut or 2 ~= oevnt then\015\n\011\011L.isDrawing = false\015\n\011\011L.mButt, L.mEvent = button, 2\015\n\011\011conSend(33, string.char(L.mButt * 16 + L.mEvent))\015\n\011end\015\n\015\n\011-- Up inside the button we started with\015\n\011if button == 1 then\015\n\011\011local ret = true\015\n\011\011for k,v in pairs(tpt_buttons) do\015\n\011\011\011if v.downInside and (mouseX>=v.x1 and mouseX<=v.x2 and mouseY>=v.y1 and mouseY<=v.y2) then\015\n\011\011\011\011if v.f() == false then ret = false end\015\n\011\011\011end\015\n\011\011\011v.downInside = nil\015\n\011\011end\015\n\011\011return ret\015\n\011end\015\nend\015\n\015\nlocal function mouseMove(mouseX, mouseY, dX, dY)\015\n\011if L.chatHidden then\015\n\011\011showbutton:mouseMove(mouseX, mouseY, dX, dY)\015\n\011\011if not hooks_enabled then\015\n\011\011\011return true\015\n\011\011end\015\n\011end\015\n\011if chatwindow:mouseMove(mouseX, mouseY, dX, dY) then\015\n\011\011return false\015\n\011end\015\n\015\n\011-- Always send mouse update, unless we're currently drawing and entered/exited the zoom window\015\n\011-- TPT sends a fake mouseup event in this case, but the mouse move happens first so we need to stop it ourselves\015\n\011local shouldBlockMove = L.isDrawing and not inZoomWindow(mouseX, mouseY) ~= inZoomWindow(L.realMouseX, L.realMouseY)\015\n\011if shouldBlockMove then\015\n\011\011L.isDrawing = false\015\n\011else\015\n\011\011sendMouseUpdate(mouseX, mouseY)\015\n\011end\015\n\015\n\011--Mouse hold, we MUST stay inside button or don't trigger on up\015\n\011if button == 1 then\015\n\011\011for k, v in pairs(tpt_buttons) do\015\n\011\011\011if v.downInside and (mouseX < v.x1 or mouseX > v.x2 or mouseY < v.y1 or mouseY > v.y2) then\015\n\011\011\011\011v.downInside = nil\015\n\011\011\011end\015\n\011\011end\015\n\011end\015\nend\015\n\015\nlocal function mouseWheel(mouseX, mouseY, wheel)\015\n\011if chatwindow.inputbox.focus and chatwindow:mouseWheel(mousex, mousey, wheel) then\015\n\011\011return false\015\n\011end\015\nend\015\n\015\nlocal keyFuncs = {\015\n\011--TAB\015\n\011[9] = function() if not jacobsmod or not L.ctrl then conSend(35) end end,\015\n\015\n\011--View modes 0-9\015\n\011[48] = function() conSend(48,\"\\10\") end,\015\n\011[49] = function() if L.shift then conSend(48,\"\\9\") tpt.display_mode(9)--[[force local display mode, screw debug check for now]] return false end conSend(48,\"\\0\") end,\015\n\011[50] = function() conSend(48,\"\\1\") end,\015\n\011[51] = function() conSend(48,\"\\2\") end,\015\n\011[52] = function() conSend(48,\"\\3\") end,\015\n\011[53] = function() conSend(48,\"\\4\") end,\015\n\011[54] = function() conSend(48,\"\\5\") end,\015\n\011[55] = function() conSend(48,\"\\6\") end,\015\n\011[56] = function() conSend(48,\"\\7\") end,\015\n\011[57] = function() conSend(48,\"\\8\") end,\015\n\015\n\011-- ins / del for replace mode\015\n\011[1073741897] = function() L.replacemode = bit.bxor(L.replacemode, 1) conSend(38, L.replacemode) end,\015\n\011[127] = function() L.replacemode = bit.bxor(L.replacemode, 2) conSend(38, L.replacemode) end,\015\n\015\n\011--Arrows for stamp adjust\015\n\011[273] = function() if L.placeStamp then L.smoved=true end end,\015\n\011[274] = function() if L.placeStamp then L.smoved=true end end,\015\n\011[275] = function() if L.placeStamp then L.smoved=true end end,\015\n\011[276] = function() if L.placeStamp then L.smoved=true end end\015\n}\015\n\015\nlocal scanFuncs = {\015\n\011--`, console\015\n\011[53] = function() if not L.shift and con.connected then infoText:reset(\"Console does not sync, use shift+` to open instead\") return false else jacobsmod_old_menu_check = true end end,\015\n\015\n\011--b, deco, pauses sim\015\n\011[5] = function() if L.ctrl then conSend(51,tpt.decorations_enable()==0 and \"\\1\" or \"\\0\") else conSend(49,\"\\1\") conSend(51,\"\\1\") end end,\015\n\015\n\011--c, copy\015\n\011[6] = function() if L.ctrl then L.stamp=true L.copying=true L.stampx = -1 L.stampy = -1 end end,\015\n\015\n\011--d key, debug, api broken right now\015\n\011--[7] = function() conSend(55) end,\015\n\015\n\011--F, frame step\015\n\011[9] = function() if not jacobsmod or not L.ctrl then conSend(50) end end,\015\n\015\n\011--H, HUD and intro text\015\n\011[11] = function() if L.ctrl and jacobsmod then return false end end,\015\n\015\n\011--I, invert pressure\015\n\011[12] = function() conSend(62) end,\015\n\015\n\011--K, stamp menu, abort our known stamp, who knows what they picked, send full screen?\015\n\011[14] = function() L.lastStamp={data=nil,w=0,h=0} L.placeStamp=true end,\015\n\015\n\011--L, last Stamp\015\n\011[15] = function() if L.lastStamp then L.placeStamp=true end end,\015\n\015\n\011--N, newtonian gravity or new save\015\n\011[17] = function() if jacobsmod and L.ctrl then L.sendScreen=2 L.lastSave=nil else conSend(54,tpt.newtonian_gravity()==0 and \"\\1\" or \"\\0\") end end,\015\n\015\n\011--O, old menu in jacobs mod\015\n\011[18] = function() if jacobsmod and not L.ctrl then jacobsmod_old_menu_check = true end end,\015\n\015\n\011--R, for stamp rotate or save reload\015\n\011[21] = function()\015\n\011\011if L.placeStamp then\015\n\011\011\011L.smoved = true\015\n\011\011\011if L.shift then\015\n\011\011\011\011return\015\n\011\011\011end\015\n\011\011\011L.rotate = not L.rotate\015\n\011\011elseif L.ctrl then\015\n\011\011\011if L.lastSave then\015\n\011\011\011\011conSend(70)\015\n\011\011\011\011infoText:reset(\"Sent reload command\") \015\n\011\011\011else\015\n\011\011\011\011L.sendScreen = true\015\n\011\011\011\011infoText:reset(\"Send sync\") \015\n\011\011\011end\015\n\011\011end\015\n\011end,\015\n\015\n\011--S, stamp\015\n\011[22] = function() if (L.lastStick2 and not L.ctrl) or (jacobsmod and L.ctrl) then return end L.stamp=true L.stampx = -1 L.stampy = -1 end,\015\n\015\n\011--T, tabs\015\n\011[23] = function() if jacobsmod then L.tabs = not L.tabs end end,\015\n\015\n\011--U, ambient heat toggle\015\n\011[24] = function() conSend(53,tpt.ambient_heat()==0 and \"\\1\" or \"\\0\") end,\015\n\015\n\011--V, paste the copystamp\015\n\011[25] = function() if L.ctrl and L.lastCopy then L.placeStamp=true L.copying=true end end,\015\n\015\n\011--W, gravity mode\015\n\011[26] = function() if L.lastStick2 and not L.ctrl then return end conSend(58,string.char((sim.gravityMode()+1)%3)) return true end,\015\n\015\n\011--X, cut a copystamp and clear\015\n\011[27] = function() if L.ctrl then L.stamp=true L.copying=1 L.stampx = -1 L.stampy = -1 end end,\015\n\015\n\011--Y, air mode\015\n\011[28] = function() if L.ctrl then L.sendScreen = true else conSend(59,string.char((sim.airMode()+1)%5)) return true end end,\015\n\015\n\011--Z\015\n\011[29] = function() if L.ctrl then L.sendScreen = true else L.skipClick=true end end,\015\n\015\n\011--ESC\015\n\011[41] = function() if not L.chatHidden then L.chatHidden = true TPTMP.chatHidden = true return false end end,\015\n\015\n\011--space, pause toggle\015\n\011[44] = function() conSend(49,tpt.set_pause()==0 and \"\\1\" or \"\\0\") end,\015\n\015\n\011--= key, pressure/spark reset\015\n\011[46] = function() if L.ctrl then conSend(60) else conSend(61) end end,\015\n\015\n\011--;, replace mode or specific delete\015\n\011[59] = function() if L.ctrl then  L.replacemode = bit.bxor(L.replacemode, 2) else  L.replacemode = bit.bxor(L.replacemode, 1) end conSend(38, L.replacemode) end,\015\n\015\n\011--F1 , intro text\015\n\011[58] = function() if jacobsmod then return false end end,\015\n\015\n\011--F5 , save reload\015\n\011[62] = function()\015\n\011\011if L.lastSave then\015\n\011\011\011conSend(70)\015\n\011\011\011infoText:reset(\"Sent reload command\") \015\n\011\011else\015\n\011\011\011L.sendScreen = true\015\n\011\011\011infoText:reset(\"Sent sync\") \015\n\011\011end\015\n\011end,\015\n}\015\nlocal scanUnpressFuncs = {\015\n\011--Z\015\n\011[29] = function() L.skipClick=false if L.alt then L.skipClick=true end end,\015\n}\015\n\015\nlocal function keypress(key, scan, rep, shift, ctrl, alt)\015\n\011if shift and not L.shift then\015\n\011\011L.shift = true\015\n\011\011conSend(36, string.char(17))\015\n\011end\015\n\011if ctrl and not L.ctrl then\015\n\011\011L.ctrl = true\015\n\011\011conSend(36, string.char(1))\015\n\011end\015\n\011if alt and not L.alt then\015\n\011\011L.alt = true\015\n\011\011conSend(36, string.char(33))\015\n\011end\015\n\015\n\011local check = chatwindow:keypress(key, scan, rep, shift, ctrl, alt)\015\n\011if type(check) == \"boolean\" then\015\n\011\011return not check\015\n\011end\015\n\011\015\n\011if rep then return end\015\n\015\n\011if scanFuncs[scan] then\015\n\011\011ret = scanFuncs[scan]()\015\n\011\011if ret ~= nil then\015\n\011\011\011return ret\015\n\011\011end\015\n\011elseif keyFuncs[key] then\015\n\011\011ret = keyFuncs[key]()\015\n\011\011if ret ~= nil then\015\n\011\011\011return ret\015\n\011\011end\015\n\011end\015\nend\015\nlocal function keyrelease(key, scan, rep, shift, ctrl, alt)\015\n\011if not shift and L.shift then\015\n\011\011L.shift = false\015\n\011\011conSend(36, string.char(16))\015\n\011end\015\n\011if not ctrl and L.ctrl then\015\n\011\011L.ctrl = false\015\n\011\011conSend(36, string.char(0))\015\n\011end\015\n\011if not alt and L.alt then\015\n\011\011L.alt = false\015\n\011\011conSend(36, string.char(32))\015\n\011end\015\n\015\n\011if rep then return end\015\n\015\n\011if scanUnpressFuncs[scan] then\015\n\011\011ret = scanUnpressFuncs[scan]()\015\n\011\011if ret~= nil then\015\n\011\011\011return ret\015\n\011\011end\015\n\011end\015\nend\015\nlocal function textinput(text)\015\n\011chatwindow:textinput(text)\015\nend\015\nlocal function blur()\015\n\011if L.shift then\015\n\011\011L.shift = false\015\n\011\011conSend(36, string.char(16))\015\n\011end\015\n\011if L.ctrl then\015\n\011\011L.ctrl = false\015\n\011\011conSend(36, string.char(0))\015\n\011end\015\n\011if L.alt then\015\n\011\011L.alt = false\015\n\011\011conSend(36, string.char(32))\015\n\011end\015\nend\015\nfunction TPTMP.disableMultiplayer()\015\n\011evt.unregister(evt.tick, step)\015\n\011evt.unregister(evt.mousedown, mouseDown)\015\n\011evt.unregister(evt.mouseup, mouseUp)\015\n\011evt.unregister(evt.mousemove, mouseMove)\015\n\011evt.unregister(evt.mousewheel, mouseQheel)\015\n\011evt.unregister(evt.keypress, keypress)\015\n\011evt.unregister(evt.keyrelease, keyrelease)\015\n\011evt.unregister(evt.textinput, textinput)\015\n\011evt.unregister(evt.blur, blur)\015\n\011TPTMP = nil\015\n\011disconnected(\"TPTMP unloaded\")\015\nend\015\n\015\nfunction TPTMP.enableMultiplayer()\015\n\011hooks_enabled = true\015\n\011TPTMP.enableMultiplayer = nil\015\n\011debug.sethook(nil,\"\",0)\015\n\011if jacobsmod then\015\n\011\011--clear intro text tooltip\015\n\011\011gfx.toolTip(\"\", 0, 0, 0, 4)\015\n\011end\015\nend\015\nTPTMP.con = con\015\nTPTMP.chatHidden = true\015\nevt.register(evt.tick, step)\015\nevt.register(evt.mousedown, mouseDown)\015\nevt.register(evt.mouseup, mouseUp)\015\nevt.register(evt.mousemove, mouseMove)\015\nevt.register(evt.mousewheel, mouseWheel)\015\nevt.register(evt.keypress, keypress)\015\nevt.register(evt.keyrelease, keyrelease)\015\nevt.register(evt.textinput, textinput)\015\nevt.register(evt.blur, blur)\015\n\015\n\015\n--Cracker1000's TPT unleashed script version 7.0\015\n--For beta version warning, 1 is on.\015\nlocal beta = 0\015\nif beta == 1 then\015\ntpt.message_box(\"You are using beta version!\",\"Some features might not work.\")\015\nend\015\n\015\nlocal toggle = Button:new(320,0,13,8, \"V\", \"Toggle additional menus.\")\015\n\015\nlocal deletesparkButton = Button:new(320,6,75,10,\"Interface\", \"shows UI related stuff.\")\015\nlocal UIhidey = Button:new(410,6,40,10,\"Hide\", \"Hides the UI\")\015\nlocal UIhiden = Button:new(410,16,40,10,\"Show\", \"Shows the UI\")\015\n\015\nlocal FPS = Button:new(320,26,75,10, \"Frame limiter\", \"Turns the frame limiter on/off.\")\015\nlocal FPS1 = Button:new(410,26,80,10, \"On\", \"Turns the frame limiter on.\")\015\nlocal FPS2 = Button:new(410,36,80,10, \"Off\", \"Turns the frame limiter off.\")\015\n\015\nlocal screen= Button:new(320,46,75,10,\"Screenshot\", \"Take a screen shot.\")\015\nlocal screen1= Button:new(300,0,15,9,\"Y\", \"Take the screen shot.\")\015\nlocal screen2= Button:new(325,0,15,9,\"N\", \"Cancel the screen shot.\")\015\n\015\nlocal reset= Button:new(320,66,75,10,\"Reset\", \"Reset everything.\")\015\n\015\nlocal info= Button:new(320,86,75,10,\"Version check\", \"Check for latest version.\")\015\n\015\nlocal Ruler = Button:new(320,106,75,10, \"Ruler\", \"Toggles in game hud ruler.\")\015\nlocal Ry = Button:new(410,106,40,10,\"Hide\", \"Hides the Ruler\")\015\nlocal Rn = Button:new(410,116,40,10,\"Show\", \"Shows the Ruler\")\015\n\015\nlocal mp = Button:new(320,126,75,10,\"Theme\", \"Changes game's theme\")\015\nlocal mp1 = Button:new(410,126,75,10,\"Default\", \"Change the theme to default\")\015\nlocal mp2 = Button:new(410,136,75,10,\"Fire\", \"Change the theme to Blue\")\015\nlocal mp3 = Button:new(410,146,75,10,\"Aqua\", \"Change the theme to Red\")\015\nlocal mp4 = Button:new(410,156,75,10,\"Forest\", \"Change the theme to Green\")\015\nlocal mp5 = Button:new(410,166,75,10,\"Sun\", \"Change the theme to Yellow\")\015\n\015\n\015\n\015\nlocal rc = Button:new(320,146,75,10,\"Record\", \"Options for recording frames\")\015\nlocal rc1 = Button:new(410,146,40,10,\"Start\", \"Starts recording\")\015\nlocal rc2 = Button:new(410,156,40,10,\"Stop\",\"Stops recording\")\015\n\015\nlocal bg = Button:new(320,166,75,10,\"Backgrounds\", \"Sets different backgrounds.\")\015\nlocal bgI = Button:new(470,166,30,10,\"^\", \"Increase brightness\")\015\nlocal bgD = Button:new(470,176,30,10,\"v\", \"Decrease brightness\")\015\nlocal bg1 = Button:new(410,166,60,10,\"BLACK\", \"Default\")\015\nlocal bg2 = Button:new(410,176,60,10,\"BLUE\", \"Blue background\")\015\nlocal bg3 = Button:new(410,186,60,10,\"RED\", \"Red background\")\015\nlocal bg4 = Button:new(410,196,60,10,\"GREEN\", \"Green background\")\015\nlocal bg5 = Button:new(410,206,60,10,\"YELLOW\", \"Yellow background\")\015\n\015\nlocal bug = Button:new(320,186,75,10,\"Bug report\", \"Direct to Mod thread for bug report.\")\015\n\015\nlocal bar = Button:new(320,206,75,10,\"Top bar\", \"Toggle top bar\")\015\nlocal bary = Button:new(410,206,75,10,\"Show\", \"Shows the bar at top\")\015\nlocal barn = Button:new(410,216,75,10,\"Hide\", \"Hides the bar\")\015\n\015\n\015\nlocal wiki  =  Button:new(320,226,75,10,\"Wiki\", \"Element wiki!\")\015\nlocal wikin2 = Button:new(10,350,75,20,\"Hide wiki \", \" Close wiki!\")\015\n\015\nlocal hide= Button:new(320,246,15,10, \"^\", \"Hide.\")\015\n\015\n\015\nfunction clearm()\015\ninterface.removeComponent(reset)\015\ninterface.removeComponent(screen)\015\ninterface.removeComponent(FPS)\015\ninterface.removeComponent(deletesparkButton)\015\ninterface.removeComponent(hide)\015\ninterface.removeComponent(info)\015\ninterface.removeComponent(Ruler)\015\ninterface.removeComponent(mp)\015\ninterface.removeComponent(rc)\015\ninterface.removeComponent(bg)\015\ninterface.removeComponent(bug)\015\ninterface.removeComponent(bar)\015\ninterface.removeComponent(wiki)\015\nend\015\n\015\nfunction clearsb()\015\ninterface.removeComponent(UIhiden)\015\ninterface.removeComponent(UIhidey)\015\ninterface.removeComponent(Ry)\015\ninterface.removeComponent(Rn)\015\ninterface.removeComponent(rc1)\015\ninterface.removeComponent(rc2)\015\ninterface.removeComponent(bg1)\015\ninterface.removeComponent(bg2)\015\ninterface.removeComponent(bg3)\015\ninterface.removeComponent(bg4)\015\ninterface.removeComponent(bg5)\015\ninterface.removeComponent(bgI)\015\ninterface.removeComponent(bgD)\015\ninterface.removeComponent(screen1)\015\ninterface.removeComponent(screen2)\015\ninterface.removeComponent(FPS1)\015\ninterface.removeComponent(FPS2)\015\ninterface.removeComponent(mp1)\015\ninterface.removeComponent(mp2)\015\ninterface.removeComponent(mp3)\015\ninterface.removeComponent(mp4)\015\ninterface.removeComponent(mp5)\015\ninterface.removeComponent(bary)\015\ninterface.removeComponent(barn)\015\ninterface.removeComponent(wikin2)\015\nend\015\n\015\nclearm()\015\nbug:action(function(sender)\015\nplatform.openLink(\"https://powdertoy.co.uk/Discussions/Thread/View.html?Thread=23279\")\015\nend)\015\n\015\nwiki:action(function(sender)\015\nclearsb()\015\nclearm()\015\ntpt.hud(0)\015\ninterface.addComponent(wikin2)\015\ntpt.register_step(wikii)\015\ntpt.register_step(backb)\015\ntpt.register_step(UIhide)\015\nend)\015\n\015\n\015\nfunction wikii()\015\ngfx.drawText(10,10, \" WELCOME TO IN GAME WIKI: \\n\\n WAll: Hybrid of walls and elements.\\n VLSN: Velocity sensor.  Creates SPRK when nearby velocity's higher than it's temp, Configured with .tmp modes.\\n TIMC: Time based convertor, converts into it's ctype when sparked with PSCN. Timer set using .tmp, default is 100.\\n FUEL: FUEL. Fuel having high calorific value.\\n THRM: Thermostat. Sets the temp of surrounding according to its own temp.\\n CLNT: Coolant. Cools down the temp of the system, evaporates at high temperatures. Use .tmp to configure. \\n DMRN: Demron. Radioactive shielding material and a better insulator.\\n FNTC & FPTC: Faster versions of NTCT and PTCT.\\n PINV: Powered Invisible, allows particles to move through when activated.\\n UVRD: Ultra violet radiations, interacts with different elements as irl.\\n SUN.: Sun, PLNT grow in direction of sunlight, emits radiation, makes PSCN spark and heals STKMs.\\n LITH: Lithium ion battery, Use with PSCN and NSCN. Charges with INST when deactivated. Life sets capacity.\\n Reacts with different elements like O2, WATR, ACID etc as IRL.\\n LED:  Light Emmiting Diode. Use with PSCN and NSCN. Temp sets the brightness.\\n Different .tmp2 modes: 0 = white, 1= red, 2= green, 3 =blue, 4= yellow and 5 = pink. \\n QGP: Quark Gluon Plasma, bursts out radiation afer sometime. Extremely violent. \\n Turns into Purple QGP when under 100C which is stable.\\n TMPS: .tmp sensor, creats sprk when there is an element with higher .tmp than its temp.\\n PHOS: White, slowly turns into red phosphorus with time. Burns blue when in contact with O2. Protect it with OIL.\\n Melts at 45C.\\n PTNM: Platinum, conducts like gold, catalyses reactions and reacts with SMKE, ISOZ, GAS, BREL and HYGN.\\n CMNT: Cement, heats up when mixed with water and gets solidified, darkens when solidified.\\n NTRG: Nitrogen gas, liquifies to LN2 when cooled or when under pressure, reacts with H2 to make NITR and puts out fire.\")\015\nend\015\n\015\nwikin2:action(function(sender)\015\nclearsb()\015\nclearm()\015\ntpt.unregister_step(wikii)\015\ntpt.unregister_step(backb)\015\ninterface.addComponent(toggle)\015\ntpt.unregister_step(UIhide)\015\ntpt.hud(1)\015\nend)\015\n\015\nbg:action(function(sender)\015\nclearsb()\015\ninterface.addComponent(bg1)\015\ninterface.addComponent(bg2)\015\ninterface.addComponent(bg3)\015\ninterface.addComponent(bg4)\015\ninterface.addComponent(bg5)\015\ninterface.addComponent(bgI)\015\ninterface.addComponent(bgD)\015\nend)\015\n\015\nlocal as = 60\015\n\015\nfunction backb()\015\ntpt.fillrect(0,0,610,385,0,0,255,as)\015\nend\015\nfunction backr()\015\ntpt.fillrect(0,0,610,385,255,0,0,as)\015\nend\015\nfunction backg()\015\ntpt.fillrect(0,0,610,385,0,255,0,as)\015\nend\015\nfunction backy()\015\ntpt.fillrect(0,0,610,385,255,255,0,as)\015\nend\015\n\015\nfunction clearbg()\015\ninterface.removeComponent(bgI)\015\ninterface.removeComponent(bgD)\015\ninterface.removeComponent(bg5)\015\ninterface.removeComponent(bg4)\015\ninterface.removeComponent(bg3)\015\ninterface.removeComponent(bg2)\015\ninterface.removeComponent(bg1)\015\ntpt.unregister_step(backy)\015\ntpt.unregister_step(backb)\015\ntpt.unregister_step(backr)\015\ntpt.unregister_step(backg)\015\nend\015\n\015\ntgr = 0\015\ntgg  = 0\015\ntgb = 200\015\n\015\nbgI:action(function(sender)\015\nas = as+30\015\nend)\015\nbgD:action(function(sender)\015\nas = as-30\015\nend)\015\n\015\nbg1:action(function(sender)\015\nclearbg()\015\ntgr = 0\015\ntgg  = 0\015\ntgb = 200\015\nend)\015\nbg2:action(function(sender)\015\ntgr = 0\015\ntgg  = 0\015\ntgb = 200\015\nclearbg()\015\ntpt.register_step(backb)\015\nend)\015\n\015\nbg3:action(function(sender)\015\ntgr = 200\015\ntgg  = 0\015\ntgb = 0\015\nclearbg()\015\ntpt.register_step(backr)\015\nend)\015\n\015\nbg4:action(function(sender)\015\ntgr = 0\015\ntgg  = 200\015\ntgb = 0\015\nclearbg()\015\ntpt.register_step(backg)\015\nend)\015\n\015\nbg5:action(function(sender)\015\ntgr = 200\015\ntgg  = 200\015\ntgb = 0\015\nclearbg()\015\ntpt.register_step(backy)\015\nend)\015\n\015\nfunction topbar()\015\ntpt.drawline(1, 0, 310, 0, ar, ag, ab,200)\015\ntpt.drawline(340, 0, 610, 0,ar, ag, ab, 200)\015\nend\015\n\015\ntpt.register_step(topbar)\015\n\015\nbar:action(function(sender)\015\nclearsb()\015\ninterface.addComponent(bary)\015\ninterface.addComponent(barn)\015\nend)\015\n\015\nbary:action(function(sender)\015\ntpt.register_step(topbar)\015\nclearsb()\015\nend)\015\n\015\n\015\nbarn:action(function(sender)\015\ntpt.unregister_step(topbar)\015\nclearsb()\015\nend)\015\n\015\nrc:action(function(sender)\015\nclearsb()\015\ninterface.addComponent(rc1)\015\ninterface.addComponent(rc2)\015\nend)\015\n\015\n\015\nrc1:action(function(sender)\015\ntpt.record(true)\015\ninterface.removeComponent(rc1)\015\ninterface.removeComponent(rc2)\015\n\015\nend)\015\n\015\nrc2:action(function(sender)\015\ntpt.record(false)\015\ninterface.removeComponent(rc1)\015\ninterface.removeComponent(rc2)\015\nend)\015\n\015\nmp:action(function(sender)\015\nclearsb()\015\ninterface.addComponent(mp1)\015\ninterface.addComponent(mp2)\015\ninterface.addComponent(mp3)\015\ninterface.addComponent(mp4)\015\ninterface.addComponent(mp5)\015\nend)\015\n\015\nfunction mpremove()\015\ninterface.removeComponent(mp1)\015\ninterface.removeComponent(mp2)\015\ninterface.removeComponent(mp3)\015\ninterface.removeComponent(mp4)\015\ninterface.removeComponent(mp5)\015\nend\015\n\015\nar =  110\015\nag = 110\015\nab = 110\015\nfunction theme()\015\ntpt.drawrect(613,1,14,405,ar,ag,ab,255)\015\ntpt.drawline(613,95,627,95,ar,ag,ab,255)\015\ntpt.drawline(613,135,627,135,ar,ag,ab,255)\015\ntpt.drawline(187,409,187,422,ar,ag,ab,255)\015\ntpt.drawline(469,408,469,421,ar,ag,ab,255)\015\ntpt.drawline(487,408,487,421,ar,ag,ab,255)\015\ntpt.drawline(241,408,241,421,ar,ag,ab,255)\015\ntpt.drawline(36,408,36,421,ar,ag,ab,255)\015\ntpt.drawline(18,408,18,421,ar,ag,ab,255)\015\ntpt.drawline(580,409,580,422,ar,ag,ab,255)\015\ntpt.drawrect(1,408,626,14,ar,ag,ab,255)\015\nend\015\n\015\nmp1:action(function(sender)\015\ntpt.unregister_step(theme)\015\nar =  110\015\nag = 110\015\nab = 110\015\nmpremove()\015\nend)\015\n\015\nmp2:action(function(sender)\015\ntpt.register_step(theme)\015\nar = 255\015\nag = 0\015\nab = 0\015\nmpremove()\015\nend)\015\n\015\nmp3:action(function(sender)\015\ntpt.register_step(theme)\015\nar = 0\015\nag = 0\015\nab = 255\015\nmpremove()\015\nend)\015\n\015\nmp4:action(function(sender)\015\ntpt.register_step(theme)\015\nar = 0\015\nag = 255\015\nab = 0\015\nmpremove()\015\nend)\015\n\015\nmp5:action(function(sender)\015\ntpt.register_step(theme)\015\nar = 250\015\nag = 250\015\nab = 0\015\nmpremove()\015\nend)\015\n\015\n\015\n\015\nRuler:action(function(sender)\015\nclearsb()\015\ninterface.addComponent(Ry)\015\ninterface.addComponent(Rn)\015\nend)\015\n\015\n\015\nRy:action(function(sender)\015\ntpt.setdebug(0X0)\015\ninterface.removeComponent(Ry)\015\ninterface.removeComponent(Rn)\015\nend)\015\n\015\nRn:action(function(sender)\015\n\015\ntpt.setdebug(0X4)\015\ninterface.removeComponent(Ry)\015\ninterface.removeComponent(Rn)\015\nend)\015\n\015\n\015\n\015\ndeletesparkButton:action(function(sender)\015\nclearsb()\015\ntpt.hud(0)\015\ninterface.addComponent(UIhidey)\015\ninterface.addComponent(UIhiden)\015\nend)\015\n\015\n\015\nfunction UIhide()\015\ntpt.hud(0)\015\ntpt.fillrect(0,382,616,42,0,0,0,255)\015\ntpt.fillrect(612,0,17,424,0,0,0,255)\015\nend\015\nUIhidey:action(function(sender)\015\ntpt.hud(0)\015\ninterface.removeComponent(UIhiden)\015\ninterface.removeComponent(UIhidey)\015\ntpt.unregister_step(topbar)\015\ntpt.register_step(UIhide)\015\nend)\015\n\015\nUIhiden:action(function(sender)\015\ntpt.hud(0)\015\ninterface.removeComponent(UIhiden)\015\ninterface.removeComponent(UIhidey)\015\ntpt.unregister_step(UIhide)\015\ntpt.register_step(topbar)\015\nend)\015\n\015\nFPS:action(function(sender)\015\nclearsb()\015\ninterface.addComponent(FPS1)\015\ninterface.addComponent(FPS2)\015\nend)\015\n\015\n\015\nFPS1:action(function(sender)\015\ninterface.removeComponent(FPS1)\015\ninterface.removeComponent(FPS2)\015\ntpt.setfpscap(60)\015\nend)\015\n\015\nFPS2:action(function(sender)\015\ninterface.removeComponent(FPS1)\015\ninterface.removeComponent(FPS2)\015\ntpt.setfpscap(160)\015\nend)\015\n\015\nscreen1:action(function(sender)\015\ninterface.removeComponent(screen1)\015\ninterface.removeComponent(screen2)\015\ntpt.drawtext(327,368,\"Cracker1000's script\", 0 , 0,255, 255)\015\ntpt.screenshot(0)\015\ninterface.addComponent(toggle)\015\nend)\015\n\015\nscreen2:action(function(sender)\015\ninterface.removeComponent(screen1)\015\ninterface.removeComponent(screen2)\015\ninterface.addComponent(toggle)\015\nend)\015\n\015\nscreen:action(function(sender)\015\nclearsb()\015\nclearm()\015\ninterface.addComponent(screen1)\015\ninterface.addComponent(screen2)\015\nend)\015\n\015\nreset:action(function(sender)\015\ntgr = 0\015\ntgg  = 0\015\ntgb = 200\015\nar =  110\015\nag = 110\015\nab = 110\015\ntpt.unregister_step(wikii)\015\ntpt.unregister_step(topbar)\015\ntpt.unregister_step(UIhide)\015\ntpt.display_mode(3)\015\ntpt.watertest(0)\015\nsim.edgeMode(0) \015\ntpt.setfpscap(60)\015\ntpt.setwindowsize(1)\015\ntpt.register_step(topbar)\015\ntpt.newtonian_gravity(0)\015\ntpt.decorations_enable(0)\015\nsim.resetPressure()\015\ntpt.unregister_step(theme)\015\ntpt.ambient_heat(0)\015\nsim.resetTemp()\015\ntpt.reset_velocity(1,380,300,300)\015\nclearbg()\015\nclearsb()\015\ntpt.setdebug(0X0)\015\nsim.clearSim()\015\nend)\015\n\015\ninfo:action(function(sender)\015\ntpt.message_box(\"Cracker1000's Script Check\",\"Version 7.0\")\015\nend)\015\n\015\nhide:action(function(sender)\015\ninterface.addComponent(toggle)\015\nclearsb()\015\nclearm()\015\ntpt.hud(1)\015\ntpt.set_pause(0)\015\nend)\015\n\015\ntoggle:action(function(sender)\015\ntpt.set_pause(1)\015\ntpt.hud(0)\015\ninterface.removeComponent(screen1)\015\ninterface.removeComponent(screen2)\015\ninterface.addComponent(deletesparkButton)\015\ninterface.addComponent(FPS)\015\ninterface.addComponent(screen)\015\ninterface.addComponent(info)\015\ninterface.addComponent(reset)\015\ninterface.addComponent(hide)\015\ninterface.addComponent(Ruler)\015\ninterface.addComponent(rc)\015\ninterface.addComponent(bg)\015\ninterface.addComponent(mp)\015\ninterface.addComponent(bug)\015\ninterface.addComponent(bar)\015\ninterface.addComponent(wiki)\015\ninterface.removeComponent(toggle)\015\nend)\015\ninterface.addComponent(toggle)\015\n\015\n\015\n\015\n";
	luaL_loadbuffer(l, crackerk_luac, crackerk_luac_sz, "@crackerk.lua");
	lua_pcall(l, 0, 0, 0);
#else
	unsigned int size = 0;
	const char* data = NULL;
	Platform::LoadFileInResource(IDI_CRK, LUASCRIPT, size, data);
	char *buffer = new char[size + 1];
	::memcpy(buffer, data, size);
	buffer[size] = 0;
	luaL_loadbuffer(l, buffer, size, "@crackerk.lua");
	lua_pcall(l, 0, 0, 0);
	delete[] buffer;
#endif
}
#endif
